{
  "language": "Solidity",
  "sources": {
    "contracts/payment/SessionsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IWrappedERC20, ERC20Wrapper} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/ERC20Wrapper.sol\";\nimport {ManagedIdentity, Ownable, Recoverable} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/Recoverable.sol\";\nimport {PayoutWallet} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/payment/PayoutWallet.sol\";\nimport {ERC20Receiver} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ERC20Receiver.sol\";\n\n/**\n * @title SessionsManager, a contract to register game sessions in REVV Racing.\n */\ncontract SessionsManager is Recoverable, ERC20Receiver, PayoutWallet {\n    using ERC20Wrapper for IWrappedERC20;\n\n    /**\n     * Event emitted when a game session has been submitted.\n     * @param account the address of the account which entered the session.\n     * @param sessionId the session identifier provided by the server.\n     * @param amount the amount of REVV paid for the session: 0 for a free session, the current session price otherwise.\n     */\n    event Admission(address account, string sessionId, uint256 amount);\n\n    IWrappedERC20 public immutable revvToken;\n\n    uint256 public freeSessions; // the total number of free sessions for each account.\n    uint256 public sessionPrice; // the current price for a single session.\n\n    mapping(address => uint256) public freeSessionsUsed; // the number of free sessions used by account.\n\n    constructor(IWrappedERC20 revvToken_, address payable payoutWallet) PayoutWallet(msg.sender, payoutWallet) {\n        revvToken = revvToken_;\n    }\n\n    /**\n     * Adds `amount` of free sessions.\n     * @dev Reverts if the sender is not the contract owner.\n     * @dev Reverts if the number of free sessions overflows.\n     * @param amount the number of additional free sessions.\n     */\n    function addFreeSessions(uint256 amount) external {\n        _requireOwnership(_msgSender());\n        uint256 freeSessions_ = freeSessions;\n        uint256 newFreeSessions = freeSessions_ + amount;\n        require(newFreeSessions > freeSessions, \"Sessions: sessions overflow\");\n        freeSessions = newFreeSessions;\n    }\n\n    /**\n     * Sets `price` as the new session price. Setting a zero price will prevent any session to be admitted.\n     * @dev Reverts if the sender is not the contract owner.\n     * @param price the new session price.\n     */\n    function setSessionPrice(uint256 price) external {\n        _requireOwnership(_msgSender());\n        sessionPrice = price;\n    }\n\n    /**\n     * Registers a user to a game session.\n     * This function is the entry point when doing a PolygonREVV `safeTransfer` or `safeTransferFrom` to this contract.\n     * @dev Reverts if the function is called from another address than the PolygonREVV contract address.\n     * @dev Reverts if the session price has not been set yet.\n     * @dev Reverts if the received value is incorrect: must be the session price, or zero in case of a free session.\n     * @dev Emits an `Admission` event.\n     * @param from the initiator of the transfer.\n     * @param value the amount of PolygonREVV received.\n     * @param data ABI-encoded string representing the session id6.\n     */\n    function onERC20Received(\n        address, /*sender*/\n        address from,\n        uint256 value,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(_msgSender() == address(revvToken), \"Sessions: wrong token\");\n        uint256 price = sessionPrice;\n        require(price != 0, \"Sessions: price not set\");\n        uint256 userFreeSessions = freeSessionsUsed[from];\n        if (userFreeSessions < freeSessions) {\n            require(value == 0, \"Sessions: session is free\");\n            freeSessionsUsed[from] = userFreeSessions + 1; // cannot overflow as user free sessions can never reach max uint256\n        } else {\n            require(value == price, \"Sessions: wrong price\");\n            revvToken.wrappedTransfer(payoutWallet, value);\n        }\n\n        emit Admission(from, abi.decode(data, (string)), value);\n\n        return _ERC20_RECEIVED;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/utils/ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {AddressIsContract} from \"./types/AddressIsContract.sol\";\n\n/**\n * @title ERC20Wrapper\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\n * Calls to the wrapped functions revert only if they throw or if they return false.\n */\nlibrary ERC20Wrapper {\n    using AddressIsContract for address;\n\n    function wrappedTransfer(\n        IWrappedERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function wrappedTransferFrom(\n        IWrappedERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function wrappedApprove(\n        IWrappedERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\n        address target = address(token);\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = target.call(callData);\n        if (success) {\n            if (data.length != 0) {\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\n            }\n        } else {\n            // revert using a standard revert message\n            if (data.length == 0) {\n                revert(\"ERC20Wrapper: operation failed\");\n            }\n\n            // revert using the revert message coming from the call\n            assembly {\n                let size := mload(data)\n                revert(add(32, data), size)\n            }\n        }\n    }\n}\n\ninterface IWrappedERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/utils/Recoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"../metatx/ManagedIdentity.sol\";\nimport {Ownable} from \"../access/Ownable.sol\";\nimport {IWrappedERC20, ERC20Wrapper} from \"./ERC20Wrapper.sol\";\n\nabstract contract Recoverable is ManagedIdentity, Ownable {\n    using ERC20Wrapper for IWrappedERC20;\n\n    /**\n     * Extract ERC20 tokens which were accidentally sent to the contract to a list of accounts.\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC20 tokens\n     * so that the extraction is limited to only amounts sent accidentally.\n     * @dev Reverts if the sender is not the contract owner.\n     * @dev Reverts if `accounts`, `tokens` and `amounts` do not have the same length.\n     * @dev Reverts if one of `tokens` is does not implement the ERC20 transfer function.\n     * @dev Reverts if one of the ERC20 transfers fail for any reason.\n     * @param accounts the list of accounts to transfer the tokens to.\n     * @param tokens the list of ERC20 token addresses.\n     * @param amounts the list of token amounts to transfer.\n     */\n    function recoverERC20s(\n        address[] calldata accounts,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external virtual {\n        _requireOwnership(_msgSender());\n        uint256 length = accounts.length;\n        require(length == tokens.length && length == amounts.length, \"Recov: inconsistent arrays\");\n        for (uint256 i = 0; i != length; ++i) {\n            IWrappedERC20(tokens[i]).wrappedTransfer(accounts[i], amounts[i]);\n        }\n    }\n\n    /**\n     * Extract ERC721 tokens which were accidentally sent to the contract to a list of accounts.\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC721 tokens\n     * so that the extraction is limited to only tokens sent accidentally.\n     * @dev Reverts if the sender is not the contract owner.\n     * @dev Reverts if `accounts`, `contracts` and `amounts` do not have the same length.\n     * @dev Reverts if one of `contracts` is does not implement the ERC721 transferFrom function.\n     * @dev Reverts if one of the ERC721 transfers fail for any reason.\n     * @param accounts the list of accounts to transfer the tokens to.\n     * @param contracts the list of ERC721 contract addresses.\n     * @param tokenIds the list of token ids to transfer.\n     */\n    function recoverERC721s(\n        address[] calldata accounts,\n        address[] calldata contracts,\n        uint256[] calldata tokenIds\n    ) external virtual {\n        _requireOwnership(_msgSender());\n        uint256 length = accounts.length;\n        require(length == contracts.length && length == tokenIds.length, \"Recov: inconsistent arrays\");\n        for (uint256 i = 0; i != length; ++i) {\n            IRecoverableERC721(contracts[i]).transferFrom(address(this), accounts[i], tokenIds[i]);\n        }\n    }\n}\n\ninterface IRecoverableERC721 {\n    /// See {IERC721-transferFrom(address,address,uint256)}\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/payment/PayoutWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"../metatx/ManagedIdentity.sol\";\nimport {Ownable} from \"../access/Ownable.sol\";\n\n/**\n    @title PayoutWallet\n    @dev adds support for a payout wallet\n    Note: .\n */\nabstract contract PayoutWallet is ManagedIdentity, Ownable {\n    event PayoutWalletSet(address payoutWallet_);\n\n    address payable public payoutWallet;\n\n    constructor(address owner, address payable payoutWallet_) Ownable(owner) {\n        require(payoutWallet_ != address(0), \"Payout: zero address\");\n        payoutWallet = payoutWallet_;\n        emit PayoutWalletSet(payoutWallet_);\n    }\n\n    function setPayoutWallet(address payable payoutWallet_) public {\n        _requireOwnership(_msgSender());\n        require(payoutWallet_ != address(0), \"Payout: zero address\");\n        payoutWallet = payoutWallet_;\n        emit PayoutWalletSet(payoutWallet);\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC165} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol\";\nimport {IERC20Receiver} from \"./IERC20Receiver.sol\";\n\nabstract contract ERC20Receiver is IERC20Receiver, IERC165 {\n    bytes4 internal constant _ERC20_RECEIVED = type(IERC20Receiver).interfaceId;\n    bytes4 internal constant _ERC20_REJECTED = 0xffffffff;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC20Receiver).interfaceId;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Partially derived from OpenZeppelin:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @dev Upgrades the address type to check if it is a contract.\n */\nlibrary AddressIsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/*\n * Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner.\n */\nabstract contract ManagedIdentity {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        return msg.data;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"../metatx/ManagedIdentity.sol\";\nimport {IERC173} from \"./IERC173.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is ManagedIdentity, IERC173 {\n    address internal _owner;\n\n    /**\n     * Initializes the contract, setting the deployer as the initial owner.\n     * @dev Emits an {IERC173-OwnershipTransferred(address,address)} event.\n     */\n    constructor(address owner_) {\n        _owner = owner_;\n        emit OwnershipTransferred(address(0), owner_);\n    }\n\n    /**\n     * Gets the address of the current contract owner.\n     */\n    function owner() public view virtual override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * See {IERC173-transferOwnership(address)}\n     * @dev Reverts if the sender is not the current contract owner.\n     * @param newOwner the address of the new owner. Use the zero address to renounce the ownership.\n     */\n    function transferOwnership(address newOwner) public virtual override {\n        _requireOwnership(_msgSender());\n        _owner = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n\n    /**\n     * @dev Reverts if `account` is not the contract owner.\n     * @param account the account to test.\n     */\n    function _requireOwnership(address account) internal virtual {\n        require(account == this.owner(), \"Ownable: not the owner\");\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-173 Contract Ownership Standard\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\n */\ninterface IERC173 {\n    /**\n     * Event emited when ownership of a contract changes.\n     * @param previousOwner the previous owner.\n     * @param newOwner the new owner.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * Get the address of the owner\n     * @return The address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * Set the address of the new owner of the contract\n     * Set newOwner to address(0) to renounce any ownership.\n     * @dev Emits an {OwnershipTransferred} event.\n     * @param newOwner The address of the new owner of the contract. Using the zero address means renouncing ownership.\n     */\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, Receiver\n * See https://eips.ethereum.org/EIPS/eip-20\n * Note: the ERC-165 identifier for this interface is 0x4fc35859.\n */\ninterface IERC20Receiver {\n    /**\n     * Handles the receipt of ERC20 tokens.\n     * @param sender The initiator of the transfer.\n     * @param from The address which transferred the tokens.\n     * @param value The amount of tokens transferred.\n     * @param data Optional additional data with no specified format.\n     * @return bytes4 `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC20Received(\n        address sender,\n        address from,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/bridging/ChildERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IChildToken} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/bridging/IChildToken.sol\";\nimport {ERC20Receiver} from \"../token/ERC20/ERC20Receiver.sol\";\n\n/**\n * Polygon (MATIC) bridging base child ERC20 for deployment on the child chain (Polygon/MATIC).\n */\nabstract contract ChildERC20Base is IChildToken, ERC20Receiver {\n    event Withdrawn(address account, uint256 value);\n\n    // see https://github.com/maticnetwork/pos-portal/blob/master/contracts/child/ChildChainManager/ChildChainManager.sol\n    address public childChainManager;\n\n    /**\n     * Constructor\n     * @param childChainManager_ the Polygon/MATIC ChildChainManager proxy address.\n     */\n    constructor(address childChainManager_) {\n        childChainManager = childChainManager_;\n    }\n\n    function _requireDepositorRole(address account) internal view {\n        require(account == childChainManager, \"ChildERC20: only depositor\");\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/bridging/IChildToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\ninterface IChildToken {\n    function deposit(address user, bytes calldata depositData) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ChildERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {ERC20Receiver, ChildERC20Base} from \"../../bridging/ChildERC20Base.sol\";\n\nabstract contract ChildERC20 is ERC20, ChildERC20Base {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        string memory tokenURI_,\n        address childChainManager\n    ) ERC20(name_, symbol_, decimals_, tokenURI_) ChildERC20Base(childChainManager) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC20, ERC20Receiver) returns (bool) {\n        return ERC20.supportsInterface(interfaceId) || ERC20Receiver.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Called when tokens have been deposited on the root chain.\n     * @dev Should handle deposit by un-escrowing the required amount for user.\n     * @dev Reverts if not sent by the depositor (ChildChainManager).\n     * @param user address for whom deposit has been done.\n     * @param depositData abi encoded amount.\n     */\n    function deposit(address user, bytes calldata depositData) public virtual override {\n        _requireDepositorRole(_msgSender());\n        uint256 amount = abi.decode(depositData, (uint256));\n        _transfer(address(this), user, amount);\n    }\n\n    /**\n     * Called when user wants to withdraw tokens back to the root chain.\n     * @dev Should escrow user's tokens. This transaction will be verified when exiting on root chain.\n     * @dev Emits a {Withdrawn} event.\n     * @param amount amount of tokens to withdraw.\n     */\n    function withdraw(uint256 amount) public virtual {\n        address sender = _msgSender();\n        _transferFrom(sender, sender, address(this), amount);\n        emit Withdrawn(sender, amount);\n    }\n\n    /**\n     * Called when user wants to withdraw tokens back to the root chain (no pre-approval required).\n     * @dev Should escrow user's tokens. This transaction will be verified when exiting on root chain.\n     * @dev Reverts if the sender is not this contract.\n     * @dev Emits a {Withdrawn} event.\n     * _param operator The initiator of the transfer.\n     * @param from The address which transferred the tokens.\n     * @param amount The amount of tokens transferred.\n     * _param data Optional additional data with no specified format.\n     * @return bytes4 `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC20Received(\n        address, /*operator*/\n        address from,\n        uint256 amount,\n        bytes calldata /*data*/\n    ) public virtual override returns (bytes4) {\n        require(_msgSender() == address(this), \"ChildERC20: wrong sender\");\n        emit Withdrawn(from, amount);\n        return _ERC20_RECEIVED;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol\";\nimport {IERC165} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol\";\nimport {AddressIsContract} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol\";\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Detailed} from \"./IERC20Detailed.sol\";\nimport {IERC20Allowance} from \"./IERC20Allowance.sol\";\nimport {IERC20SafeTransfers} from \"./IERC20SafeTransfers.sol\";\nimport {IERC20BatchTransfers} from \"./IERC20BatchTransfers.sol\";\nimport {IERC20Metadata} from \"./IERC20Metadata.sol\";\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {IERC20Receiver} from \"./IERC20Receiver.sol\";\n\n/**\n * @title ERC20 Fungible Token Contract.\n */\nabstract contract ERC20 is\n    ManagedIdentity,\n    IERC165,\n    IERC20,\n    IERC20Detailed,\n    IERC20Metadata,\n    IERC20Allowance,\n    IERC20BatchTransfers,\n    IERC20SafeTransfers,\n    IERC20Permit\n{\n    using AddressIsContract for address;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    uint256 public immutable deploymentChainId;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public override nonces;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal immutable _decimals;\n    string internal _tokenURI;\n\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n    uint256 internal _totalSupply;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        string memory tokenURI_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _tokenURI = tokenURI_;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        deploymentChainId = chainId;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        // recompute the domain separator in case of fork and chainid update\n        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId, bytes(_name));\n    }\n\n    function _calculateDomainSeparator(uint256 chainId, bytes memory name_) private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(name_),\n                    keccak256(\"1\"),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n\n    /////////////////////////////////////////// ERC165 ///////////////////////////////////////\n\n    /// @dev See {IERC165-supportsInterface}.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC20).interfaceId ||\n            interfaceId == type(IERC20Detailed).interfaceId ||\n            interfaceId == type(IERC20Metadata).interfaceId ||\n            interfaceId == type(IERC20Allowance).interfaceId ||\n            interfaceId == type(IERC20BatchTransfers).interfaceId ||\n            interfaceId == type(IERC20SafeTransfers).interfaceId ||\n            interfaceId == type(IERC20Permit).interfaceId;\n    }\n\n    /////////////////////////////////////////// ERC20Detailed ///////////////////////////////////////\n\n    /// @dev See {IERC20Detailed-name}.\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    /// @dev See {IERC20Detailed-symbol}.\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @dev See {IERC20Detailed-decimals}.\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /////////////////////////////////////////// ERC20Metadata ///////////////////////////////////////\n\n    /// @dev See {IERC20Metadata-tokenURI}.\n    function tokenURI() external view override returns (string memory) {\n        return _tokenURI;\n    }\n\n    /////////////////////////////////////////// ERC20 ///////////////////////////////////////\n\n    /// @dev See {IERC20-totalSupply}.\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev See {IERC20-balanceOf}.\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @dev See {IERC20-allowance}.\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /// @dev See {IERC20-approve}.\n    function approve(address spender, uint256 value) external virtual override returns (bool) {\n        _approve(_msgSender(), spender, value);\n        return true;\n    }\n\n    /////////////////////////////////////////// ERC20 Allowance ///////////////////////////////////////\n\n    /// @dev See {IERC20Allowance-increaseAllowance}.\n    function increaseAllowance(address spender, uint256 addedValue) external virtual override returns (bool) {\n        require(spender != address(0), \"ERC20: zero address spender\");\n        address owner = _msgSender();\n        uint256 allowance_ = _allowances[owner][spender];\n        if (addedValue != 0) {\n            uint256 newAllowance = allowance_ + addedValue;\n            require(newAllowance > allowance_, \"ERC20: allowance overflow\");\n            _allowances[owner][spender] = newAllowance;\n            allowance_ = newAllowance;\n        }\n        emit Approval(owner, spender, allowance_);\n\n        return true;\n    }\n\n    /// @dev See {IERC20Allowance-decreaseAllowance}.\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual override returns (bool) {\n        require(spender != address(0), \"ERC20: zero address spender\");\n        _decreaseAllowance(_msgSender(), spender, subtractedValue);\n        return true;\n    }\n\n    /// @dev See {IERC20-transfer}.\n    function transfer(address to, uint256 value) external virtual override returns (bool) {\n        _transfer(_msgSender(), to, value);\n        return true;\n    }\n\n    /// @dev See {IERC20-transferFrom}.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external virtual override returns (bool) {\n        _transferFrom(_msgSender(), from, to, value);\n        return true;\n    }\n\n    /////////////////////////////////////////// ERC20MultiTransfer ///////////////////////////////////////\n\n    /// @dev See {IERC20MultiTransfer-multiTransfer(address[],uint256[])}.\n    function batchTransfer(address[] calldata recipients, uint256[] calldata values) external virtual override returns (bool) {\n        uint256 length = recipients.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n        address sender = _msgSender();\n        uint256 balance = _balances[sender];\n\n        uint256 totalValue;\n        uint256 selfTransferTotalValue;\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"ERC20: to zero address\");\n\n            uint256 value = values[i];\n            if (value != 0) {\n                uint256 newTotalValue = totalValue + value;\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\n                totalValue = newTotalValue;\n                if (sender != to) {\n                    _balances[to] += value;\n                } else {\n                    require(value <= balance, \"ERC20: insufficient balance\");\n                    selfTransferTotalValue += value; // cannot overflow as 'selfTransferTotalValue <= totalValue' is always true\n                }\n            }\n            emit Transfer(sender, to, value);\n        }\n\n        if (totalValue != 0 && totalValue != selfTransferTotalValue) {\n            uint256 newBalance = balance - totalValue;\n            require(newBalance < balance, \"ERC20: insufficient balance\"); // balance must be sufficient, including self-transfers\n            _balances[sender] = newBalance + selfTransferTotalValue; // do not deduct self-transfers from the sender balance\n        }\n        return true;\n    }\n\n    /// @dev See {IERC20MultiTransfer-multiTransferFrom(address,address[],uint256[])}.\n    function batchTransferFrom(\n        address from,\n        address[] calldata recipients,\n        uint256[] calldata values\n    ) external virtual override returns (bool) {\n        uint256 length = recipients.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n\n        uint256 balance = _balances[from];\n\n        uint256 totalValue;\n        uint256 selfTransferTotalValue;\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"ERC20: to zero address\");\n\n            uint256 value = values[i];\n\n            if (value != 0) {\n                uint256 newTotalValue = totalValue + value;\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\n                totalValue = newTotalValue;\n                if (from != to) {\n                    _balances[to] += value;\n                } else {\n                    require(value <= balance, \"ERC20: insufficient balance\");\n                    selfTransferTotalValue += value; // cannot overflow as 'selfTransferTotalValue <= totalValue' is always true\n                }\n            }\n\n            emit Transfer(from, to, value);\n        }\n\n        if (totalValue != 0 && totalValue != selfTransferTotalValue) {\n            uint256 newBalance = balance - totalValue;\n            require(newBalance < balance, \"ERC20: insufficient balance\"); // balance must be sufficient, including self-transfers\n            _balances[from] = newBalance + selfTransferTotalValue; // do not deduct self-transfers from the sender balance\n        }\n\n        address sender = _msgSender();\n        if (from != sender) {\n            _decreaseAllowance(from, sender, totalValue);\n        }\n\n        return true;\n    }\n\n    /////////////////////////////////////////// ERC20SafeTransfers ///////////////////////////////////////\n\n    /// @dev See {IERC20Safe-safeTransfer(address,uint256,bytes)}.\n    function safeTransfer(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override returns (bool) {\n        address sender = _msgSender();\n        _transfer(sender, to, amount);\n        if (to.isContract()) {\n            require(IERC20Receiver(to).onERC20Received(sender, sender, amount, data) == type(IERC20Receiver).interfaceId, \"ERC20: transfer refused\");\n        }\n        return true;\n    }\n\n    /// @dev See {IERC20Safe-safeTransferFrom(address,address,uint256,bytes)}.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override returns (bool) {\n        address sender = _msgSender();\n        _transferFrom(sender, from, to, amount);\n        if (to.isContract()) {\n            require(IERC20Receiver(to).onERC20Received(sender, from, amount, data) == type(IERC20Receiver).interfaceId, \"ERC20: transfer refused\");\n        }\n        return true;\n    }\n\n    /////////////////////////////////////////// ERC20Permit ///////////////////////////////////////\n\n    /// @dev See {IERC2612-permit(address,address,uint256,uint256,uint8,bytes32,bytes32)}.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override {\n        require(owner != address(0), \"ERC20: zero address owner\");\n        require(block.timestamp <= deadline, \"ERC20: expired permit\");\n        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == owner, \"ERC20: invalid permit\");\n        _approve(owner, spender, value);\n    }\n\n    /////////////////////////////////////////// Internal Functions ///////////////////////////////////////\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal {\n        require(spender != address(0), \"ERC20: zero address spender\");\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 subtractedValue\n    ) internal {\n        uint256 allowance_ = _allowances[owner][spender];\n\n        if (allowance_ != type(uint256).max && subtractedValue != 0) {\n            // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n            uint256 newAllowance = allowance_ - subtractedValue;\n            require(newAllowance < allowance_, \"ERC20: insufficient allowance\");\n            _allowances[owner][spender] = newAllowance;\n            allowance_ = newAllowance;\n        }\n        emit Approval(owner, spender, allowance_);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual {\n        require(to != address(0), \"ERC20: to zero address\");\n\n        if (value != 0) {\n            uint256 balance = _balances[from];\n            uint256 newBalance = balance - value;\n            require(newBalance < balance, \"ERC20: insufficient balance\");\n            if (from != to) {\n                _balances[from] = newBalance;\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    function _transferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _transfer(from, to, value);\n        if (from != sender) {\n            _decreaseAllowance(from, sender, value);\n        }\n    }\n\n    function _mint(address to, uint256 value) internal virtual {\n        require(to != address(0), \"ERC20: zero address\");\n        uint256 supply = _totalSupply;\n        if (value != 0) {\n            uint256 newSupply = supply + value;\n            require(newSupply > supply, \"ERC20: supply overflow\");\n            _totalSupply = newSupply;\n            _balances[to] += value; // balance cannot overflow if supply does not\n        }\n        emit Transfer(address(0), to, value);\n    }\n\n    function _batchMint(address[] memory recipients, uint256[] memory values) internal virtual {\n        uint256 length = recipients.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n\n        uint256 totalValue;\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"ERC20: zero address\");\n\n            uint256 value = values[i];\n            if (value != 0) {\n                uint256 newTotalValue = totalValue + value;\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\n                totalValue = newTotalValue;\n                _balances[to] += value; // balance cannot overflow if supply does not\n            }\n            emit Transfer(address(0), to, value);\n        }\n\n        if (totalValue != 0) {\n            uint256 supply = _totalSupply;\n            uint256 newSupply = supply + totalValue;\n            require(newSupply > supply, \"ERC20: supply overflow\");\n            _totalSupply = newSupply;\n        }\n    }\n\n    function _burn(address from, uint256 value) internal virtual {\n        if (value != 0) {\n            uint256 balance = _balances[from];\n            uint256 newBalance = balance - value;\n            require(newBalance < balance, \"ERC20: insufficient balance\");\n            _balances[from] = newBalance;\n            _totalSupply -= value; // will not underflow if balance does not\n        }\n        emit Transfer(from, address(0), value);\n    }\n\n    function _burnFrom(address from, uint256 value) internal virtual {\n        _burn(from, value);\n        address sender = _msgSender();\n        if (from != sender) {\n            _decreaseAllowance(from, sender, value);\n        }\n    }\n\n    function _batchBurnFrom(address[] memory owners, uint256[] memory values) internal virtual {\n        uint256 length = owners.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n\n        address sender = _msgSender();\n\n        uint256 totalValue;\n        for (uint256 i; i != length; ++i) {\n            address from = owners[i];\n            uint256 value = values[i];\n            if (value != 0) {\n                uint256 balance = _balances[from];\n                uint256 newBalance = balance - value;\n                require(newBalance < balance, \"ERC20: insufficient balance\");\n                _balances[from] = newBalance;\n                totalValue += value; // totalValue cannot overflow if the individual balances do not underflow\n            }\n            emit Transfer(from, address(0), value);\n\n            if (from != sender) {\n                _decreaseAllowance(from, sender, value);\n            }\n        }\n\n        if (totalValue != 0) {\n            _totalSupply -= totalValue; // _totalSupply cannot underfow as balances do not underflow\n        }\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, basic interface\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * Note: The ERC-165 identifier for this interface is 0x36372b07.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when tokens are transferred, including zero value transfers.\n     * @param _from The account where the transferred tokens are withdrawn from.\n     * @param _to The account where the transferred tokens are deposited to.\n     * @param _value The amount of tokens being transferred.\n     */\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n     * @dev Emitted when a successful call to {IERC20-approve(address,uint256)} is made.\n     * @param _owner The account granting an allowance to `_spender`.\n     * @param _spender The account being granted an allowance from `_owner`.\n     * @param _value The allowance amount being granted.\n     */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n     * @notice Returns the total token supply.\n     * @return The total token supply.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns the account balance of another account with address `owner`.\n     * @param owner The account whose balance will be returned.\n     * @return The account balance of another account with address `owner`.\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * Transfers `value` amount of tokens to address `to`.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender does not have enough balance.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\n     * @param to The receiver account.\n     * @param value The amount of tokens to transfer.\n     * @return True if the transfer succeeds, false otherwise.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @notice Transfers `value` amount of tokens from address `from` to address `to` via the approval mechanism.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not `from` and has not been approved by `from` for at least `value`.\n     * @dev Reverts if `from` does not have at least `value` of balance.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\n     * @param from The emitter account.\n     * @param to The receiver account.\n     * @param value The amount of tokens to transfer.\n     * @return True if the transfer succeeds, false otherwise.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /**\n     * Sets `value` as the allowance from the caller to `spender`.\n     *  IMPORTANT: Beware that changing an allowance with this method brings the risk\n     *  that someone may use both the old and the new allowance by unfortunate\n     *  transaction ordering. One possible solution to mitigate this race\n     *  condition is to first reduce the spender's allowance to 0 and set the\n     *  desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @dev Reverts if `spender` is the zero address.\n     * @dev Emits the {IERC20-Approval} event.\n     * @param spender The account being granted the allowance by the message caller.\n     * @param value The allowance amount to grant.\n     * @return True if the approval succeeds, false otherwise.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * Returns the amount which `spender` is allowed to spend on behalf of `owner`.\n     * @param owner The account that has granted an allowance to `spender`.\n     * @param spender The account that was granted an allowance by `owner`.\n     * @return The amount which `spender` is allowed to spend on behalf of `owner`.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Detailed\n * See https://eips.ethereum.org/EIPS/eip-20\n * Note: the ERC-165 identifier for this interface is 0xa219a025.\n */\ninterface IERC20Detailed {\n    /**\n     * Returns the name of the token. E.g. \"My Token\".\n     * @return The name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * Returns the symbol of the token. E.g. \"HIX\".\n     * @return The symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * Returns the number of decimals used to display the balances.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it does  not impact the arithmetic of the contract.\n     * @return The number of decimals used to display the balances.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Allowance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Allowance\n * See https://eips.ethereum.org/EIPS/eip-20\n * Note: the ERC-165 identifier for this interface is 0xd5b86388.\n */\ninterface IERC20Allowance {\n    /**\n     * Increases the allowance granted by the sender to `spender` by `value`.\n     *  This is an alternative to {approve} that can be used as a mitigation for\n     *  problems described in {IERC20-approve}.\n     * @dev Reverts if `spender` is the zero address.\n     * @dev Reverts if `spender`'s allowance overflows.\n     * @dev Emits an {IERC20-Approval} event with an updated allowance for `spender`.\n     * @param spender The account whose allowance is being increased by the message caller.\n     * @param value The allowance amount increase.\n     * @return True if the allowance increase succeeds, false otherwise.\n     */\n    function increaseAllowance(address spender, uint256 value) external returns (bool);\n\n    /**\n     * Decreases the allowance granted by the sender to `spender` by `value`.\n     *  This is an alternative to {approve} that can be used as a mitigation for\n     *  problems described in {IERC20-approve}.\n     * @dev Reverts if `spender` is the zero address.\n     * @dev Reverts if `spender` has an allowance with the message caller for less than `value`.\n     * @dev Emits an {IERC20-Approval} event with an updated allowance for `spender`.\n     * @param spender The account whose allowance is being decreased by the message caller.\n     * @param value The allowance amount decrease.\n     * @return True if the allowance decrease succeeds, false otherwise.\n     */\n    function decreaseAllowance(address spender, uint256 value) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20SafeTransfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Safe Transfers\n * Note: the ERC-165 identifier for this interface is 0x53f41a97.\n */\ninterface IERC20SafeTransfers {\n    /**\n     * Transfers tokens from the caller to `to`. If this address is a contract, then calls `onERC20Received(address,address,uint256,bytes)` on it.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `value` is greater than the sender's balance.\n     * @dev Reverts if `to` is a contract which does not implement `onERC20Received(address,address,uint256,bytes)`.\n     * @dev Reverts if `to` is a contract and the call to `onERC20Received(address,address,uint256,bytes)` returns a wrong value.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @param to The address for the tokens to be transferred to.\n     * @param amount The amount of tokens to be transferred.\n     * @param data Optional additional data with no specified format, to be passed to the receiver contract.\n     * @return true.\n     */\n    function safeTransfer(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    /**\n     * Transfers tokens from `from` to another address, using the allowance mechanism.\n     *  If this address is a contract, then calls `onERC20Received(address,address,uint256,bytes)` on it.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `value` is greater than `from`'s balance.\n     * @dev Reverts if the sender does not have at least `value` allowance by `from`.\n     * @dev Reverts if `to` is a contract which does not implement `onERC20Received(address,address,uint256,bytes)`.\n     * @dev Reverts if `to` is a contract and the call to `onERC20Received(address,address,uint256,bytes)` returns a wrong value.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @param from The address which owns the tokens to be transferred.\n     * @param to The address for the tokens to be transferred to.\n     * @param amount The amount of tokens to be transferred.\n     * @param data Optional additional data with no specified format, to be passed to the receiver contract.\n     * @return true.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20BatchTransfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Multi Transfers\n * Note: the ERC-165 identifier for this interface is 0xd5b86388.\n */\ninterface IERC20BatchTransfers {\n    /**\n     * Moves multiple `amounts` tokens from the caller's account to each of `recipients`.\n     * @dev Reverts if `recipients` and `amounts` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if the caller has an insufficient balance.\n     * @dev Emits an {IERC20-Transfer} event for each individual transfer.\n     * @param recipients the list of recipients to transfer the tokens to.\n     * @param amounts the amounts of tokens to transfer to each of `recipients`.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external returns (bool);\n\n    /**\n     * Moves multiple `amounts` tokens from an account to each of `recipients`, using the approval mechanism.\n     * @dev Reverts if `recipients` and `amounts` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if `from` has an insufficient balance.\n     * @dev Reverts if the sender does not have at least the sum of all `amounts` as allowance by `from`.\n     * @dev Emits an {IERC20-Transfer} event for each individual transfer.\n     * @dev Emits an {IERC20-Approval} event.\n     * @param from The address which owns the tokens to be transferred.\n     * @param recipients the list of recipients to transfer the tokens to.\n     * @param amounts the amounts of tokens to transfer to each of `recipients`.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function batchTransferFrom(\n        address from,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, ERC1046 optional extension: Metadata\n * See https://eips.ethereum.org/EIPS/eip-1046\n * Note: the ERC-165 identifier for this interface is 0x3c130d90.\n */\ninterface IERC20Metadata {\n    /**\n     * Returns a distinct Uniform Resource Identifier (URI) for the token metadata.\n     * @return a distinct Uniform Resource Identifier (URI) for the token metadata.\n     */\n    function tokenURI() external view returns (string memory);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, ERC2612 optional extension: permit – 712-signed approvals\n * @dev Interface for allowing ERC20 approvals to be made via ECDSA `secp256k1` signatures.\n * See https://eips.ethereum.org/EIPS/eip-2612\n * Note: the ERC-165 identifier for this interface is 0x9d8ff7da.\n */\ninterface IERC20Permit {\n    /**\n     * Sets `value` as the allowance of `spender` over the tokens of `owner`, given `owner` account's signed permit.\n     * @dev WARNING: The standard ERC-20 race condition for approvals applies to `permit()` as well: https://swcregistry.io/docs/SWC-114\n     * @dev Reverts if `owner` is the zero address.\n     * @dev Reverts if the current blocktime is > `deadline`.\n     * @dev Reverts if `r`, `s`, and `v` is not a valid `secp256k1` signature from `owner`.\n     * @dev Emits an {IERC20-Approval} event.\n     * @param owner The token owner granting the allowance to `spender`.\n     * @param spender The token spender being granted the allowance by `owner`.\n     * @param value The token amount of the allowance.\n     * @param deadline The deadline from which the permit signature is no longer valid.\n     * @param v Permit signature v parameter\n     * @param r Permit signature r parameter.\n     * @param s Permis signature s parameter.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * Returns the current permit nonce of `owner`.\n     * @param owner the address to check the nonce of.\n     * @return the current permit nonce of `owner`.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * Returns the EIP-712 encoded hash struct of the domain-specific information for permits.\n     *\n     * @dev A common ERC-20 permit implementation choice for the `DOMAIN_SEPARATOR` is:\n     *\n     *  keccak256(\n     *      abi.encode(\n     *          keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n     *          keccak256(bytes(name)),\n     *          keccak256(bytes(version)),\n     *          chainId,\n     *          address(this)))\n     *\n     *  where\n     *   - `name` (string) is the ERC-20 token name.\n     *   - `version` (string) refers to the ERC-20 token contract version.\n     *   - `chainId` (uint256) is the chain ID to which the ERC-20 token contract is deployed to.\n     *   - `verifyingContract` (address) is the ERC-20 token contract address.\n     *\n     * @return the EIP-712 encoded hash struct of the domain-specific information for permits.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/ERC1155721Inventory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC721} from \"./../ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"./../ERC721/IERC721Metadata.sol\";\nimport {IERC721BatchTransfer} from \"./../ERC721/IERC721BatchTransfer.sol\";\nimport {IERC721Receiver} from \"./../ERC721/IERC721Receiver.sol\";\nimport {IERC1155721Inventory} from \"./IERC1155721Inventory.sol\";\nimport {IERC165, IERC1155TokenReceiver, ERC1155InventoryIdentifiersLib, ERC1155InventoryBase} from \"./../ERC1155/ERC1155InventoryBase.sol\";\nimport {AddressIsContract} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol\";\n\n/**\n * @title ERC1155721Inventory, an ERC1155Inventory with additional support for ERC721.\n */\nabstract contract ERC1155721Inventory is IERC1155721Inventory, IERC721Metadata, IERC721BatchTransfer, ERC1155InventoryBase {\n    using ERC1155InventoryIdentifiersLib for uint256;\n    using AddressIsContract for address;\n\n    uint256 internal constant _APPROVAL_BIT_TOKEN_OWNER_ = 1 << 160;\n\n    string internal _name;\n    string internal _symbol;\n\n    /* owner => NFT balance */\n    mapping(address => uint256) internal _nftBalances;\n\n    /* NFT ID => operator */\n    mapping(uint256 => address) internal _nftApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /// @dev See {IERC165-supportsInterface(bytes4)}.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721BatchTransfer).interfaceId ||\n            super.supportsInterface(interfaceId);\n        // return interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    //===================================== ERC721 ==========================================/\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @dev See {IERC721-balanceOf(address)}.\n    function balanceOf(address tokenOwner) external view virtual override returns (uint256) {\n        require(tokenOwner != address(0), \"Inventory: zero address\");\n        return _nftBalances[tokenOwner];\n    }\n\n    /// @dev See {IERC721-ownerOf(uint256)} and {IERC1155Inventory-ownerOf(uint256)}.\n    function ownerOf(uint256 nftId) public view virtual override(IERC1155721Inventory, ERC1155InventoryBase) returns (address) {\n        return super.ownerOf(nftId);\n    }\n\n    /// @dev See {IERC721-approve(address,uint256)}.\n    function approve(address to, uint256 nftId) external virtual override {\n        address tokenOwner = ownerOf(nftId);\n        require(to != tokenOwner, \"Inventory: self-approval\");\n        require(_isOperatable(tokenOwner, _msgSender()), \"Inventory: non-approved sender\");\n        _owners[nftId] = uint256(uint160(tokenOwner)) | _APPROVAL_BIT_TOKEN_OWNER_;\n        _nftApprovals[nftId] = to;\n        emit Approval(tokenOwner, to, nftId);\n    }\n\n    /// @dev See {IERC721-getApproved(uint256)}.\n    function getApproved(uint256 nftId) external view virtual override returns (address) {\n        uint256 tokenOwner = _owners[nftId];\n        require(address(uint160(tokenOwner)) != address(0), \"Inventory: non-existing NFT\");\n        if (tokenOwner & _APPROVAL_BIT_TOKEN_OWNER_ != 0) {\n            return _nftApprovals[nftId];\n        } else {\n            return address(0);\n        }\n    }\n\n    /**\n     * Unsafely transfers a Non-Fungible Token (ERC721-compatible).\n     * @dev See {IERC1155721Inventory-transferFrom(address,address,uint256)}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 nftId\n    ) public virtual override {\n        _transferFrom(\n            from,\n            to,\n            nftId,\n            \"\",\n            /* safe */\n            false\n        );\n    }\n\n    /**\n     * Safely transfers a Non-Fungible Token (ERC721-compatible).\n     * @dev See {IERC1155721Inventory-safeTransferFrom(address,address,uint256)}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId\n    ) public virtual override {\n        _transferFrom(\n            from,\n            to,\n            nftId,\n            \"\",\n            /* safe */\n            true\n        );\n    }\n\n    /**\n     * Safely transfers a Non-Fungible Token (ERC721-compatible).\n     * @dev See {IERC1155721Inventory-safeTransferFrom(address,address,uint256,bytes)}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) public virtual override {\n        _transferFrom(\n            from,\n            to,\n            nftId,\n            data,\n            /* safe */\n            true\n        );\n    }\n\n    /**\n     * Unsafely transfers a batch of Non-Fungible Tokens (ERC721-compatible).\n     * @dev See {IERC1155721BatchTransfer-batchTransferFrom(address,address,uint256[])}.\n     */\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory nftIds\n    ) public virtual override {\n        require(to != address(0), \"Inventory: transfer to zero\");\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            values[i] = 1;\n            _transferNFT(from, to, nftId, 1, operatable, true);\n            emit Transfer(from, to, nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n            _transferNFTUpdateBalances(from, to, length);\n        }\n\n        emit TransferBatch(_msgSender(), from, to, nftIds, values);\n        if (to.isContract() && _isERC1155TokenReceiver(to)) {\n            _callOnERC1155BatchReceived(from, to, nftIds, values, \"\");\n        }\n    }\n\n    /// @dev See {IERC721Metadata-tokenURI(uint256)}.\n    function tokenURI(uint256 nftId) external view virtual override returns (string memory) {\n        require(address(uint160(_owners[nftId])) != address(0), \"Inventory: non-existing NFT\");\n        return uri(nftId);\n    }\n\n    //================================== ERC1155 =======================================/\n\n    /**\n     * Safely transfers some token (ERC1155-compatible).\n     * @dev See {IERC1155721Inventory-safeTransferFrom(address,address,uint256,uint256,bytes)}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        address sender = _msgSender();\n        require(to != address(0), \"Inventory: transfer to zero\");\n        bool operatable = _isOperatable(from, sender);\n\n        if (id.isFungibleToken()) {\n            _transferFungible(from, to, id, value, operatable);\n        } else if (id.isNonFungibleToken()) {\n            _transferNFT(from, to, id, value, operatable, false);\n            emit Transfer(from, to, id);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        if (to.isContract()) {\n            _callOnERC1155Received(from, to, id, value, data);\n        }\n    }\n\n    /**\n     * Safely transfers a batch of tokens (ERC1155-compatible).\n     * @dev See {IERC1155721Inventory-safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        // internal function to avoid stack too deep error\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    //================================== ERC1155MetadataURI =======================================/\n\n    /// @dev See {IERC1155MetadataURI-uri(uint256)}.\n    function uri(uint256) public view virtual override returns (string memory);\n\n    //================================== ABI-level Internal Functions =======================================/\n\n    /**\n     * Safely or unsafely transfers some token (ERC721-compatible).\n     * @dev For `safe` transfer, see {IERC1155721Inventory-transferFrom(address,address,uint256)}.\n     * @dev For un`safe` transfer, see {IERC1155721Inventory-safeTransferFrom(address,address,uint256,bytes)}.\n     */\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes memory data,\n        bool safe\n    ) internal {\n        require(to != address(0), \"Inventory: transfer to zero\");\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        _transferNFT(from, to, nftId, 1, operatable, false);\n\n        emit Transfer(from, to, nftId);\n        emit TransferSingle(sender, from, to, nftId, 1);\n        if (to.isContract()) {\n            if (_isERC1155TokenReceiver(to)) {\n                _callOnERC1155Received(from, to, nftId, 1, data);\n            } else if (safe) {\n                _callOnERC721Received(from, to, nftId, data);\n            }\n        }\n    }\n\n    /**\n     * Safely transfers a batch of tokens (ERC1155-compatible).\n     * @dev See {IERC1155721Inventory-safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)}.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"Inventory: transfer to zero\");\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        uint256 nftsCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            if (id.isFungibleToken()) {\n                _transferFungible(from, to, id, values[i], operatable);\n            } else if (id.isNonFungibleToken()) {\n                _transferNFT(from, to, id, values[i], operatable, true);\n                emit Transfer(from, to, id);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n                        nfCollectionId = nextCollectionId;\n                        nftsCount += nfCollectionCount;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n            nftsCount += nfCollectionCount;\n            _transferNFTUpdateBalances(from, to, nftsCount);\n        }\n\n        emit TransferBatch(_msgSender(), from, to, ids, values);\n        if (to.isContract()) {\n            _callOnERC1155BatchReceived(from, to, ids, values, data);\n        }\n    }\n\n    /**\n     * Safely or unsafely mints some token (ERC721-compatible).\n     * @dev For `safe` mint, see {IERC1155721InventoryMintable-mint(address,uint256)}.\n     * @dev For un`safe` mint, see {IERC1155721InventoryMintable-safeMint(address,uint256,bytes)}.\n     */\n    function _mint(\n        address to,\n        uint256 nftId,\n        bytes memory data,\n        bool safe\n    ) internal {\n        require(to != address(0), \"Inventory: mint to zero\");\n        require(nftId.isNonFungibleToken(), \"Inventory: not an NFT\");\n\n        _mintNFT(to, nftId, 1, false);\n\n        emit Transfer(address(0), to, nftId);\n        emit TransferSingle(_msgSender(), address(0), to, nftId, 1);\n        if (to.isContract()) {\n            if (_isERC1155TokenReceiver(to)) {\n                _callOnERC1155Received(address(0), to, nftId, 1, data);\n            } else if (safe) {\n                _callOnERC721Received(address(0), to, nftId, data);\n            }\n        }\n    }\n\n    /**\n     * Unsafely mints a batch of Non-Fungible Tokens (ERC721-compatible).\n     * @dev See {IERC1155721InventoryMintable-batchMint(address,uint256[])}.\n     */\n    function _batchMint(address to, uint256[] memory nftIds) internal {\n        require(to != address(0), \"Inventory: mint to zero\");\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            require(nftId.isNonFungibleToken(), \"Inventory: not an NFT\");\n            values[i] = 1;\n            _mintNFT(to, nftId, 1, true);\n            emit Transfer(address(0), to, nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _balances[nfCollectionId][to] += nfCollectionCount;\n                    _supplies[nfCollectionId] += nfCollectionCount;\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        _balances[nfCollectionId][to] += nfCollectionCount;\n        _supplies[nfCollectionId] += nfCollectionCount;\n        _nftBalances[to] += length;\n\n        emit TransferBatch(_msgSender(), address(0), to, nftIds, values);\n        if (to.isContract() && _isERC1155TokenReceiver(to)) {\n            _callOnERC1155BatchReceived(address(0), to, nftIds, values, \"\");\n        }\n    }\n\n    /**\n     * Safely mints some token (ERC1155-compatible).\n     * @dev See {IERC1155721InventoryMintable-safeMint(address,uint256,uint256,bytes)}.\n     */\n    function _safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"Inventory: mint to zero\");\n        address sender = _msgSender();\n        if (id.isFungibleToken()) {\n            _mintFungible(to, id, value);\n        } else if (id.isNonFungibleToken()) {\n            _mintNFT(to, id, value, false);\n            emit Transfer(address(0), to, id);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, address(0), to, id, value);\n        if (to.isContract()) {\n            _callOnERC1155Received(address(0), to, id, value, data);\n        }\n    }\n\n    /**\n     * Safely mints a batch of tokens (ERC1155-compatible).\n     * @dev See {IERC1155721InventoryMintable-safeBatchMint(address,uint256[],uint256[],bytes)}.\n     */\n    function _safeBatchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"Inventory: mint to zero\");\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        uint256 nftsCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n            if (id.isFungibleToken()) {\n                _mintFungible(to, id, value);\n            } else if (id.isNonFungibleToken()) {\n                _mintNFT(to, id, value, true);\n                emit Transfer(address(0), to, id);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _balances[nfCollectionId][to] += nfCollectionCount;\n                        _supplies[nfCollectionId] += nfCollectionCount;\n                        nfCollectionId = nextCollectionId;\n                        nftsCount += nfCollectionCount;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _balances[nfCollectionId][to] += nfCollectionCount;\n            _supplies[nfCollectionId] += nfCollectionCount;\n            nftsCount += nfCollectionCount;\n            _nftBalances[to] += nftsCount;\n        }\n\n        emit TransferBatch(_msgSender(), address(0), to, ids, values);\n        if (to.isContract()) {\n            _callOnERC1155BatchReceived(address(0), to, ids, values, data);\n        }\n    }\n\n    /**\n     * Safely mints some tokens to a list of recipients.\n     * @dev Reverts if `recipients`, `ids` and `values` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if one of `ids` is not a token.\n     * @dev Reverts if one of `ids` represents a non-fungible token and its `value` is not 1.\n     * @dev Reverts if one of `ids` represents a non-fungible token which has already been minted.\n     * @dev Reverts if one of `ids` represents a fungible token and its `value` is 0.\n     * @dev Reverts if one of `ids` represents a fungible token and there is an overflow of supply.\n     * @dev Reverts if one of `recipients` is a contract and the call to {IERC1155TokenReceiver-onERC1155Received}\n     *  or {IERC721Receiver-onERC721Received} fails or is refused.\n     * @dev Emits an {IERC721-Transfer} event from the zero address for each `id` representing a non-fungible token.\n     * @dev Emits an {IERC1155-TransferSingle} event from the zero address.\n     * @param recipients Addresses of the new token owners.\n     * @param ids Identifiers of the tokens to mint.\n     * @param values Amounts of tokens to mint.\n     * @param data Optional data to send along to the receiver contract(s), if any. All receivers receive the same data.\n     */\n    function _safeDeliver(\n        address[] calldata recipients,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) internal {\n        uint256 length = recipients.length;\n        require(length == ids.length && length == values.length, \"Inventory: inconsistent arrays\");\n\n        address sender = _msgSender();\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"Inventory: mint to zero\");\n            uint256 id = ids[i];\n            uint256 value = values[i];\n            if (id.isFungibleToken()) {\n                _mintFungible(to, id, value);\n                emit TransferSingle(sender, address(0), to, id, value);\n                if (to.isContract()) {\n                    _callOnERC1155Received(address(0), to, id, value, data);\n                }\n            } else if (id.isNonFungibleToken()) {\n                _mintNFT(to, id, value, false);\n                emit Transfer(address(0), to, id);\n                emit TransferSingle(sender, address(0), to, id, 1);\n                if (to.isContract()) {\n                    if (_isERC1155TokenReceiver(to)) {\n                        _callOnERC1155Received(address(0), to, id, 1, data);\n                    } else {\n                        _callOnERC721Received(address(0), to, id, data);\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n    }\n\n    //============================== Internal Helper Functions =======================================/\n\n    function _mintFungible(\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal {\n        require(value != 0, \"Inventory: zero value\");\n        uint256 supply = _supplies[id];\n        uint256 newSupply = supply + value;\n        require(newSupply > supply, \"Inventory: supply overflow\");\n        _supplies[id] = newSupply;\n        // cannot overflow as supply cannot overflow\n        _balances[id][to] += value;\n    }\n\n    function _mintNFT(\n        address to,\n        uint256 id,\n        uint256 value,\n        bool isBatch\n    ) internal {\n        require(value == 1, \"Inventory: wrong NFT value\");\n        require(_owners[id] == 0, \"Inventory: existing/burnt NFT\");\n\n        _owners[id] = uint256(uint160(to));\n\n        if (!isBatch) {\n            uint256 collectionId = id.getNonFungibleCollection();\n            // it is virtually impossible that a non-fungible collection supply\n            // overflows due to the cost of minting individual tokens\n            ++_supplies[collectionId];\n            ++_balances[collectionId][to];\n            ++_nftBalances[to];\n        }\n    }\n\n    function _transferFungible(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bool operatable\n    ) internal {\n        require(operatable, \"Inventory: non-approved sender\");\n        require(value != 0, \"Inventory: zero value\");\n        uint256 balance = _balances[id][from];\n        require(balance >= value, \"Inventory: not enough balance\");\n        if (from != to) {\n            _balances[id][from] = balance - value;\n            // cannot overflow as supply cannot overflow\n            _balances[id][to] += value;\n        }\n    }\n\n    function _transferNFT(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bool operatable,\n        bool isBatch\n    ) internal virtual {\n        require(value == 1, \"Inventory: wrong NFT value\");\n        uint256 owner = _owners[id];\n        require(from == address(uint160(owner)), \"Inventory: non-owned NFT\");\n        if (!operatable) {\n            require((owner & _APPROVAL_BIT_TOKEN_OWNER_ != 0) && _msgSender() == _nftApprovals[id], \"Inventory: non-approved sender\");\n        }\n        _owners[id] = uint256(uint160(to));\n        if (!isBatch) {\n            _transferNFTUpdateBalances(from, to, 1);\n            _transferNFTUpdateCollection(from, to, id.getNonFungibleCollection(), 1);\n        }\n    }\n\n    function _transferNFTUpdateBalances(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        if (from != to) {\n            // cannot underflow as balance is verified through ownership\n            _nftBalances[from] -= amount;\n            //  cannot overflow as supply cannot overflow\n            _nftBalances[to] += amount;\n        }\n    }\n\n    function _transferNFTUpdateCollection(\n        address from,\n        address to,\n        uint256 collectionId,\n        uint256 amount\n    ) internal virtual {\n        if (from != to) {\n            // cannot underflow as balance is verified through ownership\n            _balances[collectionId][from] -= amount;\n            // cannot overflow as supply cannot overflow\n            _balances[collectionId][to] += amount;\n        }\n    }\n\n    ///////////////////////////////////// Receiver Calls Internal /////////////////////////////////////\n\n    /**\n     * Queries whether a contract implements ERC1155TokenReceiver.\n     * @param _contract address of the contract.\n     * @return wheter the given contract implements ERC1155TokenReceiver.\n     */\n    function _isERC1155TokenReceiver(address _contract) internal view returns (bool) {\n        bool success;\n        bool result;\n        bytes memory staticCallData = abi.encodeWithSelector(type(IERC165).interfaceId, type(IERC1155TokenReceiver).interfaceId);\n        assembly {\n            let call_ptr := add(0x20, staticCallData)\n            let call_size := mload(staticCallData)\n            let output := mload(0x40) // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\n            result := mload(output)\n        }\n        // (10000 / 63) \"not enough for supportsInterface(...)\" // consume all gas, so caller can potentially know that there was not enough gas\n        assert(gasleft() > 158);\n        return success && result;\n    }\n\n    /**\n     * Calls {IERC721Receiver-onERC721Received} on a target contract.\n     * @dev Reverts if `to` is not a contract.\n     * @dev Reverts if the call to the target fails or is refused.\n     * @param from Previous token owner.\n     * @param to New token owner.\n     * @param nftId Identifier of the token transferred.\n     * @param data Optional data to send along with the receiver contract call.\n     */\n    function _callOnERC721Received(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) internal {\n        require(\n            IERC721Receiver(to).onERC721Received(_msgSender(), from, nftId, data) == type(IERC721Receiver).interfaceId,\n            \"Inventory: transfer refused\"\n        );\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC721 Non-Fungible Token Standard, basic interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n * Note: The ERC-165 identifier for this interface is 0x80ac58cd.\n */\ninterface IERC721 {\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n     * Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return balance uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * Gets the owner of the specified ID\n     * @param tokenId uint256 ID to query the owner of\n     * @return owner address currently marked as the owner of the given ID\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * Approves another address to transfer the given token ID\n     * @dev The zero address indicates there is no approved address.\n     * @dev There can only be one approved address per token at a given time.\n     * @dev Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * Gets the approved address for a token ID, or zero if no address set\n     * @dev Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return operator address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * Sets or unsets the approval of a given operator\n     * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param operator operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * Transfers the ownership of a given token ID to another address\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * Safely transfers the ownership of a given token ID to another address\n     *\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * Safely transfers the ownership of a given token ID to another address\n     *\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n * Note: The ERC-165 identifier for this interface is 0x5b5e139f.\n */\ninterface IERC721Metadata {\n    /**\n     * @dev Gets the token name\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Gets the token symbol\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns an URI for a given token ID\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     * @return string URI of given token ID\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC721/IERC721BatchTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC721 Non-Fungible Token Standard, optional unsafe batchTransfer interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n * Note: The ERC-165 identifier for this interface is.\n */\ninterface IERC721BatchTransfer {\n    /**\n     * Unsafely transfers a batch of tokens.\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if one of `tokenIds` is not owned by `from`.\n     * @dev Resets the token approval for each of `tokenIds`.\n     * @dev Emits an {IERC721-Transfer} event for each of `tokenIds`.\n     * @param from Current tokens owner.\n     * @param to Address of the new token owner.\n     * @param tokenIds Identifiers of the tokens to transfer.\n     */\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata tokenIds\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n    @title ERC721 Non-Fungible Token Standard, token receiver\n    @dev See https://eips.ethereum.org/EIPS/eip-721\n    Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.\n    Note: The ERC-165 identifier for this interface is 0x150b7a02.\n */\ninterface IERC721Receiver {\n    /**\n        @notice Handle the receipt of an NFT\n        @dev The ERC721 smart contract calls this function on the recipient\n        after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n        otherwise the caller will revert the transaction. The selector to be\n        returned can be obtained as `this.onERC721Received.selector`. This\n        function MAY throw to revert and reject the transfer.\n        Note: the ERC721 contract address is always the message sender.\n        @param operator The address which called `safeTransferFrom` function\n        @param from The address which previously owned the token\n        @param tokenId The NFT identifier which is being transferred\n        @param data Additional data with no specified format\n        @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721Inventory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC1155Inventory} from \"../ERC1155/IERC1155Inventory.sol\";\nimport {IERC1155721} from \"./IERC1155721.sol\";\n\n/**\n * @title IERC1155721Inventory interface.\n */\ninterface IERC1155721Inventory is IERC1155721, IERC1155Inventory {\n    /// @dev See {IERC721-ownerOf(uint256)} and {IERC1155Inventory-ownerOf(uint256)}.\n    function ownerOf(uint256 nftId) external view override(IERC1155721, IERC1155Inventory) returns (address);\n\n    /**\n     * @notice this documentation overrides {IERC1155Inventory-safeTransferFrom(address,address,uint256,uint256,bytes)}.\n     * Safely transfers some token.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `id` does not represent a token.\n     * @dev Reverts if `id` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if `id` represents a non-fungible token and is not owned by `from`.\n     * @dev Reverts if `id` represents a fungible token and `value` is 0.\n     * @dev Reverts if `id` represents a fungible token and `from` has an insufficient balance.\n     * @dev Reverts if `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155received} fails or is refused.\n     * @dev Resets the ERC721 single token approval if `id` represents a non-fungible token.\n     * @dev Emits an {IERC721-Transfer} event if `id` represents a non-fungible token.\n     * @dev Emits an {IERC1155-TransferSingle} event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param id Identifier of the token to transfer.\n     * @param value Amount of token to transfer.\n     * @param data Optional data to pass to the receiver contract.\n     */\n    // function safeTransferFrom(\n    //     address from,\n    //     address to,\n    //     uint256 id,\n    //     uint256 value,\n    //     bytes calldata data\n    // ) external;\n    /**\n     * @notice this documentation overrides {IERC1155Inventory-safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)}.\n     * Safely transfers a batch of tokens.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if one of `ids` does not represent a token.\n     * @dev Reverts if one of `ids` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if one of `ids` represents a non-fungible token and is not owned by `from`.\n     * @dev Reverts if one of `ids` represents a fungible token and `value` is 0.\n     * @dev Reverts if one of `ids` represents a fungible token and `from` has an insufficient balance.\n     * @dev Reverts if one of `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155batchReceived} fails or is refused.\n     * @dev Resets the ERC721 single token approval for each transferred non-fungible token.\n     * @dev Emits an {IERC721-Transfer} event for each transferred non-fungible token.\n     * @dev Emits an {IERC1155-TransferBatch} event.\n     * @param from Current tokens owner.\n     * @param to Address of the new tokens owner.\n     * @param ids Identifiers of the tokens to transfer.\n     * @param values Amounts of tokens to transfer.\n     * @param data Optional data to pass to the receiver contract.\n     */\n    // function safeBatchTransferFrom(\n    //     address from,\n    //     address to,\n    //     uint256[] calldata ids,\n    //     uint256[] calldata values,\n    //     bytes calldata data\n    // ) external;\n    /**\n     * @notice this documentation overrides its IERC721 counterpart.\n     * Unsafely transfers a Non-Fungible Token.\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `nftId` is not owned by `from`.\n     * @dev Reverts if `to` is an IERC1155TokenReceiver contract which refuses the receiver call.\n     * @dev Resets the ERC721 single token approval.\n     * @dev Emits an {IERC721-Transfer} event.\n     * @dev Emits an {IERC1155-TransferSingle} event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param nftId Identifier of the token to transfer.\n     */\n    // function transferFrom(\n    //     address from,\n    //     address to,\n    //     uint256 nftId\n    // ) external;\n    /**\n     * @notice this documentation overrides its IERC721 counterpart.\n     * Safely transfers a Non-Fungible Token.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `nftId` is not owned by `from`.\n     * @dev Reverts if `to` is a contract which does not implement IERC1155TokenReceiver or IERC721Receiver.\n     * @dev Reverts if `to` is an IERC1155TokenReceiver or IERC721Receiver contract which refuses the transfer.\n     * @dev Resets the ERC721 single token approval.\n     * @dev Emits an {IERC721-Transfer} event.\n     * @dev Emits an {IERC1155-TransferSingle} event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param nftId Identifier of the token to transfer.\n     */\n    // function safeTransferFrom(\n    //     address from,\n    //     address to,\n    //     uint256 nftId\n    // ) external;\n    /**\n     * @notice this documentation overrides its IERC721 counterpart.\n     * Safely transfers a Non-Fungible Token.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `nftId` is not owned by `from`.\n     * @dev Reverts if `to` is a contract which does not implement IERC1155TokenReceiver or IERC721Receiver.\n     * @dev Reverts if `to` is an IERC1155TokenReceiver or IERC721Receiver contract which refuses the transfer.\n     * @dev Resets the ERC721 single token approval.\n     * @dev Emits an {IERC721-Transfer} event.\n     * @dev Emits an {IERC1155-TransferSingle} event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param nftId Identifier of the token to transfer.\n     * @param data Optional data to pass to the receiver contract.\n     */\n    // function safeTransferFrom(\n    //     address from,\n    //     address to,\n    //     uint256 nftId,\n    //     bytes calldata data\n    // ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/ERC1155InventoryBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC1155} from \"./../ERC1155/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"./../ERC1155/IERC1155MetadataURI.sol\";\nimport {IERC1155Inventory} from \"./../ERC1155/IERC1155Inventory.sol\";\nimport {IERC1155InventoryTotalSupply} from \"./../ERC1155/IERC1155InventoryTotalSupply.sol\";\nimport {IERC1155TokenReceiver} from \"./../ERC1155/IERC1155TokenReceiver.sol\";\nimport {IERC165} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol\";\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol\";\n\n/**\n * @title ERC1155InventoryIdentifiersLib, a library to introspect inventory identifiers.\n * @dev With N=32, representing the Non-Fungible Collection mask length, identifiers are represented as follow:\n * (a) a Fungible Token:\n *     - most significant bit == 0\n * (b) a Non-Fungible Collection:\n *     - most significant bit == 1\n *     - (256-N) least significant bits == 0\n * (c) a Non-Fungible Token:\n *     - most significant bit == 1\n *     - (256-N) least significant bits != 0\n */\nlibrary ERC1155InventoryIdentifiersLib {\n    // Non-fungible bit. If an id has this bit set, it is a non-fungible (either collection or token)\n    uint256 internal constant _NF_BIT = 1 << 255;\n\n    // Mask for non-fungible collection (including the nf bit)\n    uint256 internal constant _NF_COLLECTION_MASK = uint256(type(uint32).max) << 224;\n    uint256 internal constant _NF_TOKEN_MASK = ~_NF_COLLECTION_MASK;\n\n    function isFungibleToken(uint256 id) internal pure returns (bool) {\n        return id & _NF_BIT == 0;\n    }\n\n    function isNonFungibleToken(uint256 id) internal pure returns (bool) {\n        return id & _NF_BIT != 0 && id & _NF_TOKEN_MASK != 0;\n    }\n\n    function getNonFungibleCollection(uint256 nftId) internal pure returns (uint256) {\n        return nftId & _NF_COLLECTION_MASK;\n    }\n}\n\nabstract contract ERC1155InventoryBase is IERC165, IERC1155, IERC1155MetadataURI, IERC1155Inventory, IERC1155InventoryTotalSupply, ManagedIdentity {\n    using ERC1155InventoryIdentifiersLib for uint256;\n\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant _ERC1155_RECEIVED = 0xf23a6e61;\n\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant _ERC1155_BATCH_RECEIVED = 0xbc197c81;\n\n    // Burnt non-fungible token owner's magic value\n    uint256 internal constant _BURNT_NFT_OWNER = 0xdead000000000000000000000000000000000000000000000000000000000000;\n\n    /* owner => operator => approved */\n    mapping(address => mapping(address => bool)) internal _operators;\n\n    /* collection ID => owner => balance */\n    mapping(uint256 => mapping(address => uint256)) internal _balances;\n\n    /* collection ID => supply */\n    mapping(uint256 => uint256) internal _supplies;\n\n    /* NFT ID => owner */\n    mapping(uint256 => uint256) internal _owners;\n\n    /* collection ID => creator */\n    mapping(uint256 => address) internal _creators;\n\n    /// @dev See {IERC165-supportsInterface}.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            interfaceId == type(IERC1155Inventory).interfaceId ||\n            interfaceId == type(IERC1155InventoryTotalSupply).interfaceId;\n    }\n\n    //================================== ERC1155 =======================================/\n\n    /// @dev See {IERC1155-balanceOf(address,uint256)}.\n    function balanceOf(address owner, uint256 id) public view virtual override returns (uint256) {\n        require(owner != address(0), \"Inventory: zero address\");\n\n        if (id.isNonFungibleToken()) {\n            return address(uint160(_owners[id])) == owner ? 1 : 0;\n        }\n\n        return _balances[id][owner];\n    }\n\n    /// @dev See {IERC1155-balanceOfBatch(address[],uint256[])}.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view virtual override returns (uint256[] memory) {\n        require(owners.length == ids.length, \"Inventory: inconsistent arrays\");\n\n        uint256[] memory balances = new uint256[](owners.length);\n\n        for (uint256 i = 0; i != owners.length; ++i) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n\n        return balances;\n    }\n\n    /// @dev See {IERC1155-setApprovalForAll(address,bool)}.\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        address sender = _msgSender();\n        require(operator != sender, \"Inventory: self-approval\");\n        _operators[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /// @dev See {IERC1155-isApprovedForAll(address,address)}.\n    function isApprovedForAll(address tokenOwner, address operator) public view virtual override returns (bool) {\n        return _operators[tokenOwner][operator];\n    }\n\n    //================================== ERC1155Inventory =======================================/\n\n    /// @dev See {IERC1155Inventory-isFungible(uint256)}.\n    function isFungible(uint256 id) external pure virtual override returns (bool) {\n        return id.isFungibleToken();\n    }\n\n    /// @dev See {IERC1155Inventory-collectionOf(uint256)}.\n    function collectionOf(uint256 nftId) external pure virtual override returns (uint256) {\n        require(nftId.isNonFungibleToken(), \"Inventory: not an NFT\");\n        return nftId.getNonFungibleCollection();\n    }\n\n    /// @dev See {IERC1155Inventory-ownerOf(uint256)}.\n    function ownerOf(uint256 nftId) public view virtual override returns (address) {\n        address owner = address(uint160(_owners[nftId]));\n        require(owner != address(0), \"Inventory: non-existing NFT\");\n        return owner;\n    }\n\n    /// @dev See {IERC1155Inventory-totalSupply(uint256)}.\n    function totalSupply(uint256 id) external view virtual override returns (uint256) {\n        if (id.isNonFungibleToken()) {\n            return address(uint160(_owners[id])) == address(0) ? 0 : 1;\n        } else {\n            return _supplies[id];\n        }\n    }\n\n    //================================== ABI-level Internal Functions =======================================/\n\n    /**\n     * Creates a collection (optional).\n     * @dev Reverts if `collectionId` does not represent a collection.\n     * @dev Reverts if `collectionId` has already been created.\n     * @dev Emits a {IERC1155Inventory-CollectionCreated} event.\n     * @param collectionId Identifier of the collection.\n     */\n    function _createCollection(uint256 collectionId) internal virtual {\n        require(!collectionId.isNonFungibleToken(), \"Inventory: not a collection\");\n        require(_creators[collectionId] == address(0), \"Inventory: existing collection\");\n        _creators[collectionId] = _msgSender();\n        emit CollectionCreated(collectionId, collectionId.isFungibleToken());\n    }\n\n    /// @dev See {IERC1155InventoryCreator-creator(uint256)}.\n    function _creator(uint256 collectionId) internal view virtual returns (address) {\n        require(!collectionId.isNonFungibleToken(), \"Inventory: not a collection\");\n        return _creators[collectionId];\n    }\n\n    //================================== Internal Helper Functions =======================================/\n\n    /**\n     * Returns whether `sender` is authorised to make a transfer on behalf of `from`.\n     * @param from The address to check operatibility upon.\n     * @param sender The sender address.\n     * @return True if sender is `from` or an operator for `from`, false otherwise.\n     */\n    function _isOperatable(address from, address sender) internal view virtual returns (bool) {\n        return (from == sender) || _operators[from][sender];\n    }\n\n    /**\n     * Calls {IERC1155TokenReceiver-onERC1155Received} on a target contract.\n     * @dev Reverts if `to` is not a contract.\n     * @dev Reverts if the call to the target fails or is refused.\n     * @param from Previous token owner.\n     * @param to New token owner.\n     * @param id Identifier of the token transferred.\n     * @param value Amount of token transferred.\n     * @param data Optional data to send along with the receiver contract call.\n     */\n    function _callOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        require(IERC1155TokenReceiver(to).onERC1155Received(_msgSender(), from, id, value, data) == _ERC1155_RECEIVED, \"Inventory: transfer refused\");\n    }\n\n    /**\n     * Calls {IERC1155TokenReceiver-onERC1155batchReceived} on a target contract.\n     * @dev Reverts if `to` is not a contract.\n     * @dev Reverts if the call to the target fails or is refused.\n     * @param from Previous tokens owner.\n     * @param to New tokens owner.\n     * @param ids Identifiers of the tokens to transfer.\n     * @param values Amounts of tokens to transfer.\n     * @param data Optional data to send along with the receiver contract call.\n     */\n    function _callOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        require(\n            IERC1155TokenReceiver(to).onERC1155BatchReceived(_msgSender(), from, ids, values, data) == _ERC1155_BATCH_RECEIVED,\n            \"Inventory: transfer refused\"\n        );\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155Inventory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-1155 Multi Token Standard, optional Inventory extension\n * @dev See https://eips.ethereum.org/EIPS/eip-xxxx\n * Interface for fungible/non-fungible tokens management on a 1155-compliant contract.\n *\n * This interface rationalizes the co-existence of fungible and non-fungible tokens\n * within the same contract. As several kinds of fungible tokens can be managed under\n * the Multi-Token standard, we consider that non-fungible tokens can be classified\n * under their own specific type. We introduce the concept of non-fungible collection\n * and consider the usage of 3 types of identifiers:\n * (a) Fungible Token identifiers, each representing a set of Fungible Tokens,\n * (b) Non-Fungible Collection identifiers, each representing a set of Non-Fungible Tokens (this is not a token),\n * (c) Non-Fungible Token identifiers. \n\n * Identifiers nature\n * |       Type                | isFungible  | isCollection | isToken |\n * |  Fungible Token           |   true      |     true     |  true   |\n * |  Non-Fungible Collection  |   false     |     true     |  false  |\n * |  Non-Fungible Token       |   false     |     false    |  true   |\n *\n * Identifiers compatibilities\n * |       Type                |  transfer  |   balance    |   supply    |  owner  |\n * |  Fungible Token           |    OK      |     OK       |     OK      |   NOK   |\n * |  Non-Fungible Collection  |    NOK     |     OK       |     OK      |   NOK   |\n * |  Non-Fungible Token       |    OK      |   0 or 1     |   0 or 1    |   OK    |\n *\n * Note: The ERC-165 identifier for this interface is 0x469bd23f.\n */\ninterface IERC1155Inventory {\n    /**\n     * Optional event emitted when a collection (Fungible Token or Non-Fungible Collection) is created.\n     *  This event can be used by a client application to determine which identifiers are meaningful\n     *  to track through the functions `balanceOf`, `balanceOfBatch` and `totalSupply`.\n     * @dev This event MUST NOT be emitted twice for the same `collectionId`.\n     */\n    event CollectionCreated(uint256 indexed collectionId, bool indexed fungible);\n\n    /**\n     * Retrieves the owner of a non-fungible token (ERC721-compatible).\n     * @dev Reverts if `nftId` is owned by the zero address.\n     * @param nftId Identifier of the token to query.\n     * @return Address of the current owner of the token.\n     */\n    function ownerOf(uint256 nftId) external view returns (address);\n\n    /**\n     * Introspects whether or not `id` represents a fungible token.\n     *  This function MUST return true even for a fungible token which is not-yet created.\n     * @param id The identifier to query.\n     * @return bool True if `id` represents afungible token, false otherwise.\n     */\n    function isFungible(uint256 id) external pure returns (bool);\n\n    /**\n     * Introspects the non-fungible collection to which `nftId` belongs.\n     * @dev This function MUST return a value representing a non-fungible collection.\n     * @dev This function MUST return a value for a non-existing token, and SHOULD NOT be used to check the existence of a non-fungible token.\n     * @dev Reverts if `nftId` does not represent a non-fungible token.\n     * @param nftId The token identifier to query the collection of.\n     * @return The non-fungible collection identifier to which `nftId` belongs.\n     */\n    function collectionOf(uint256 nftId) external pure returns (uint256);\n\n    /**\n     * @notice this documentation overrides {IERC1155-balanceOf(address,uint256)}.\n     * Retrieves the balance of `id` owned by account `owner`.\n     * @param owner The account to retrieve the balance of.\n     * @param id The identifier to retrieve the balance of.\n     * @return\n     *  If `id` represents a collection (fungible token or non-fungible collection), the balance for this collection.\n     *  If `id` represents a non-fungible token, 1 if the token is owned by `owner`, else 0.\n     */\n    // function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /**\n     * @notice this documentation overrides {IERC1155-balanceOfBatch(address[],uint256[])}.\n     * Retrieves the balances of `ids` owned by accounts `owners`.\n     * @dev Reverts if `owners` and `ids` have different lengths.\n     * @param owners The accounts to retrieve the balances of.\n     * @param ids The identifiers to retrieve the balances of.\n     * @return An array of elements such as for each pair `id`/`owner`:\n     *  If `id` represents a collection (fungible token or non-fungible collection), the balance for this collection.\n     *  If `id` represents a non-fungible token, 1 if the token is owned by `owner`, else 0.\n     */\n    // function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @notice this documentation overrides its {IERC1155-safeTransferFrom(address,address,uint256,uint256,bytes)}.\n     * Safely transfers some token.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `id` does not represent a token.\n     * @dev Reverts if `id` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if `id` represents a non-fungible token and is not owned by `from`.\n     * @dev Reverts if `id` represents a fungible token and `value` is 0.\n     * @dev Reverts if `id` represents a fungible token and `from` has an insufficient balance.\n     * @dev Reverts if `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155received} fails or is refused.\n     * @dev Emits an {IERC1155-TransferSingle} event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param id Identifier of the token to transfer.\n     * @param value Amount of token to transfer.\n     * @param data Optional data to pass to the receiver contract.\n     */\n    // function safeTransferFrom(\n    //     address from,\n    //     address to,\n    //     uint256 id,\n    //     uint256 value,\n    //     bytes calldata data\n    // ) external;\n\n    /**\n     * @notice this documentation overrides its {IERC1155-safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)}.\n     * Safely transfers a batch of tokens.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if one of `ids` does not represent a token.\n     * @dev Reverts if one of `ids` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if one of `ids` represents a non-fungible token and is not owned by `from`.\n     * @dev Reverts if one of `ids` represents a fungible token and `value` is 0.\n     * @dev Reverts if one of `ids` represents a fungible token and `from` has an insufficient balance.\n     * @dev Reverts if one of `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155batchReceived} fails or is refused.\n     * @dev Emits an {IERC1155-TransferBatch} event.\n     * @param from Current tokens owner.\n     * @param to Address of the new tokens owner.\n     * @param ids Identifiers of the tokens to transfer.\n     * @param values Amounts of tokens to transfer.\n     * @param data Optional data to pass to the receiver contract.\n     */\n    // function safeBatchTransferFrom(\n    //     address from,\n    //     address to,\n    //     uint256[] calldata ids,\n    //     uint256[] calldata values,\n    //     bytes calldata data\n    // ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC1155} from \"../ERC1155/IERC1155.sol\";\n\n/**\n * @title ERC1155721\n */\ninterface IERC1155721 is IERC1155 {\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /**\n     * Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return balance uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * Gets the owner of the specified ID\n     * @param tokenId uint256 ID to query the owner of\n     * @return owner address currently marked as the owner of the given ID\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * Approves another address to transfer the given token ID\n     * @dev The zero address indicates there is no approved address.\n     * @dev There can only be one approved address per token at a given time.\n     * @dev Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * Gets the approved address for a token ID, or zero if no address set\n     * @dev Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return operator address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * Transfers the ownership of a given token ID to another address\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * Safely transfers the ownership of a given token ID to another address\n     *\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * Safely transfers the ownership of a given token ID to another address\n     *\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * @dev Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-1155 Multi Token Standard, basic interface\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n * Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface IERC1155 {\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n     * Safely transfers some token.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `from` has an insufficient balance.\n     * @dev Reverts if `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155received} fails or is refused.\n     * @dev Emits a `TransferSingle` event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param id Identifier of the token to transfer.\n     * @param value Amount of token to transfer.\n     * @param data Optional data to send along to a receiver contract.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * Safely transfers a batch of tokens.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `ids` and `values` have different lengths.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `from` has an insufficient balance for any of `ids`.\n     * @dev Reverts if `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155batchReceived} fails or is refused.\n     * @dev Emits a `TransferBatch` event.\n     * @param from Current token owner.\n     * @param to Address of the new token owner.\n     * @param ids Identifiers of the tokens to transfer.\n     * @param values Amounts of tokens to transfer.\n     * @param data Optional data to send along to a receiver contract.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    /**\n     * Retrieves the balance of `id` owned by account `owner`.\n     * @param owner The account to retrieve the balance of.\n     * @param id The identifier to retrieve the balance of.\n     * @return The balance of `id` owned by account `owner`.\n     */\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /**\n     * Retrieves the balances of `ids` owned by accounts `owners`. For each pair:\n     * @dev Reverts if `owners` and `ids` have different lengths.\n     * @param owners The addresses of the token holders\n     * @param ids The identifiers to retrieve the balance of.\n     * @return The balances of `ids` owned by accounts `owners`.\n     */\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * Enables or disables an operator's approval.\n     * @dev Emits an `ApprovalForAll` event.\n     * @param operator Address of the operator.\n     * @param approved True to approve the operator, false to revoke an approval.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * Retrieves the approval status of an operator for a given owner.\n     * @param owner Address of the authorisation giver.\n     * @param operator Address of the operator.\n     * @return True if the operator is approved, false if not.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-1155 Multi Token Standard, optional metadata URI extension\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n * Note: The ERC-165 identifier for this interface is 0x0e89341c.\n */\ninterface IERC1155MetadataURI {\n    /**\n     * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n     * @dev URIs are defined in RFC 3986.\n     * @dev The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n     * @dev The uri function SHOULD be used to retrieve values if no event was emitted.\n     * @dev The uri function MUST return the same value as the latest event for an _id if it was emitted.\n     * @dev The uri function MUST NOT be used to check for the existence of a token as it is possible for\n     *  an implementation to return a valid string even if the token does not exist.\n     * @return URI string\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155InventoryTotalSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-1155 Multi Token Standard, optional InventoryTotalSupply extension\n * @dev See https://eips.ethereum.org/EIPS/eip-xxxx\n * Note: The ERC-165 identifier for this interface is 0xTODO.\n */\ninterface IERC1155InventoryTotalSupply {\n    /**\n     * Retrieves the total supply of `id`.\n     * @param id The identifier for which to retrieve the supply of.\n     * @return\n     *  If `id` represents a collection (fungible token or non-fungible collection), the total supply for this collection.\n     *  If `id` represents a non-fungible token, 1 if the token exists, else 0.\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-1155 Multi Token Standard, token receiver\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n * Interface for any contract that wants to support transfers from ERC1155 asset contracts.\n * Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n */\ninterface IERC1155TokenReceiver {\n    /**\n     * @notice Handle the receipt of a single ERC1155 token type.\n     * An ERC1155 contract MUST call this function on a recipient contract, at the end of a `safeTransferFrom` after the balance update.\n     * This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     *  (i.e. 0xf23a6e61) to accept the transfer.\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n     * @param operator  The address which initiated the transfer (i.e. msg.sender)\n     * @param from      The address which previously owned the token\n     * @param id        The ID of the token being transferred\n     * @param value     The amount of tokens being transferred\n     * @param data      Additional data with no specified format\n     * @return bytes4   `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice Handle the receipt of multiple ERC1155 token types.\n     * An ERC1155 contract MUST call this function on a recipient contract, at the end of a `safeBatchTransferFrom` after the balance updates.\n     * This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     *  (i.e. 0xbc197c81) if to accept the transfer(s).\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n     * @param operator  The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from      The address which previously owned the token\n     * @param ids       An array containing ids of each token being transferred (order and length must match _values array)\n     * @param values    An array containing amounts of each token being transferred (order and length must match _ids array)\n     * @param data      Additional data with no specified format\n     * @return          `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/lifecycle/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"../metatx/ManagedIdentity.sol\";\n\n/**\n * @dev Contract which allows children to implement pausability.\n */\nabstract contract Pausable is ManagedIdentity {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool public paused;\n\n    constructor(bool paused_) {\n        paused = paused_;\n    }\n\n    function _requireNotPaused() internal view {\n        require(!paused, \"Pausable: paused\");\n    }\n\n    function _requirePaused() internal view {\n        require(paused, \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual {\n        _requireNotPaused();\n        paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual {\n        _requirePaused();\n        paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/token/ERC155721/REVVMotorsportInventory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n// solhint-disable max-line-length\nimport {ERC1155721Inventory, ERC1155721InventoryBurnable} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/ERC1155721InventoryBurnable.sol\";\nimport {IERC1155721InventoryMintable} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721InventoryMintable.sol\";\nimport {IERC1155721InventoryDeliverable} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721InventoryDeliverable.sol\";\nimport {IERC1155InventoryCreator} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155InventoryCreator.sol\";\nimport {BaseMetadataURI} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/metadata/BaseMetadataURI.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/access/MinterRole.sol\";\nimport {ManagedIdentity, Recoverable} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/Recoverable.sol\";\nimport {Pausable} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/lifecycle/Pausable.sol\";\nimport {IForwarderRegistry, UsingUniversalForwarding} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol\";\n\n// solhint-enable max-line-length\n\ncontract REVVMotorsportInventory is\n    ERC1155721InventoryBurnable,\n    IERC1155721InventoryMintable,\n    IERC1155721InventoryDeliverable,\n    IERC1155InventoryCreator,\n    BaseMetadataURI,\n    MinterRole,\n    Pausable,\n    Recoverable,\n    UsingUniversalForwarding\n{\n    constructor(IForwarderRegistry forwarderRegistry, address universalForwarder)\n        ERC1155721Inventory(\"REVV Motorsport Inventory\", \"REVVM\")\n        MinterRole(msg.sender)\n        Pausable(false)\n        UsingUniversalForwarding(forwarderRegistry, universalForwarder)\n    {}\n\n    // ===================================================================================================\n    //                                 User Public Functions\n    // ===================================================================================================\n\n    /// @dev See {IERC165-supportsInterface}.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC1155InventoryCreator).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    //================================== ERC1155MetadataURI =======================================/\n\n    /// @dev See {IERC1155MetadataURI-uri(uint256)}.\n    function uri(uint256 id) public view virtual override returns (string memory) {\n        return _uri(id);\n    }\n\n    //================================== ERC1155InventoryCreator =======================================/\n\n    /// @dev See {IERC1155InventoryCreator-creator(uint256)}.\n    function creator(uint256 collectionId) external view override returns (address) {\n        return _creator(collectionId);\n    }\n\n    // ===================================================================================================\n    //                               Admin Public Functions\n    // ===================================================================================================\n\n    // Destroys the contract\n    function deprecate() external {\n        _requirePaused();\n        address payable sender = _msgSender();\n        _requireOwnership(sender);\n        selfdestruct(sender);\n    }\n\n    /**\n     * Creates a collection.\n     * @dev Reverts if the sender is not the contract owner.\n     * @dev Reverts if `collectionId` does not represent a collection.\n     * @dev Reverts if `collectionId` has already been created.\n     * @dev Emits a {IERC1155Inventory-CollectionCreated} event.\n     * @param collectionId Identifier of the collection.\n     */\n    function createCollection(uint256 collectionId) external {\n        _requireOwnership(_msgSender());\n        _createCollection(collectionId);\n    }\n\n    //================================== Pausable =======================================/\n\n    function pause() external virtual {\n        _requireOwnership(_msgSender());\n        _pause();\n    }\n\n    function unpause() external virtual {\n        _requireOwnership(_msgSender());\n        _unpause();\n    }\n\n    //================================== ERC721 =======================================/\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 nftId\n    ) public virtual override {\n        _requireNotPaused();\n        super.transferFrom(from, to, nftId);\n    }\n\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory nftIds\n    ) public virtual override {\n        _requireNotPaused();\n        super.batchTransferFrom(from, to, nftIds);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId\n    ) public virtual override {\n        _requireNotPaused();\n        super.safeTransferFrom(from, to, nftId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) public virtual override {\n        _requireNotPaused();\n        super.safeTransferFrom(from, to, nftId, data);\n    }\n\n    function batchBurnFrom(address from, uint256[] memory nftIds) public virtual override {\n        _requireNotPaused();\n        super.batchBurnFrom(from, nftIds);\n    }\n\n    //================================== ERC1155 =======================================/\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        _requireNotPaused();\n        super.safeTransferFrom(from, to, id, value, data);\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        _requireNotPaused();\n        super.safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) public virtual override {\n        _requireNotPaused();\n        super.burnFrom(from, id, value);\n    }\n\n    function batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual override {\n        _requireNotPaused();\n        super.batchBurnFrom(from, ids, values);\n    }\n\n    //================================== ERC1155721InventoryMintable =======================================/\n\n    /**\n     * Unsafely mints a Non-Fungible Token (ERC721-compatible).\n     * @dev See {IERC1155721InventoryMintable-batchMint(address,uint256)}.\n     */\n    function mint(address to, uint256 nftId) public virtual override {\n        _requireMinter(_msgSender());\n        _mint(to, nftId, \"\", false);\n    }\n\n    /**\n     * Unsafely mints a batch of Non-Fungible Tokens (ERC721-compatible).\n     * @dev See {IERC1155721InventoryMintable-batchMint(address,uint256[])}.\n     */\n    function batchMint(address to, uint256[] memory nftIds) public virtual override {\n        _requireMinter(_msgSender());\n        _batchMint(to, nftIds);\n    }\n\n    /**\n     * Safely mints a Non-Fungible Token (ERC721-compatible).\n     * @dev See {IERC1155721InventoryMintable-safeMint(address,uint256,bytes)}.\n     */\n    function safeMint(\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _mint(to, nftId, data, true);\n    }\n\n    /**\n     * Safely mints some token (ERC1155-compatible).\n     * @dev See {IERC1155721InventoryMintable-safeMint(address,uint256,uint256,bytes)}.\n     */\n    function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _safeMint(to, id, value, data);\n    }\n\n    /**\n     * Safely mints a batch of tokens (ERC1155-compatible).\n     * @dev See {IERC1155721InventoryMintable-safeBatchMint(address,uint256[],uint256[],bytes)}.\n     */\n    function safeBatchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _safeBatchMint(to, ids, values, data);\n    }\n\n    /**\n     * Safely mints tokens to recipients.\n     * @dev See {IERC1155721InventoryDeliverable-safeDeliver(address[],uint256[],uint256[],bytes)}.\n     */\n    function safeDeliver(\n        address[] calldata recipients,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external virtual override {\n        _requireMinter(_msgSender());\n        _safeDeliver(recipients, ids, values, data);\n    }\n\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\n        return UsingUniversalForwarding._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\n        return UsingUniversalForwarding._msgData();\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/ERC1155721InventoryBurnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC1155721InventoryBurnable} from \"./IERC1155721InventoryBurnable.sol\";\nimport {ERC1155InventoryIdentifiersLib, ERC1155721Inventory} from \"./ERC1155721Inventory.sol\";\n\n/**\n * @title ERC1155721InventoryBurnable, a burnable ERC1155721Inventory.\n */\nabstract contract ERC1155721InventoryBurnable is IERC1155721InventoryBurnable, ERC1155721Inventory {\n    using ERC1155InventoryIdentifiersLib for uint256;\n\n    //================================== ERC165 =======================================/\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC1155721InventoryBurnable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    //============================== ERC1155721InventoryBurnable =======================================/\n\n    /**\n     * Burns some token (ERC1155-compatible).\n     * @dev See {IERC1155721InventoryBurnable-burnFrom(address,uint256,uint256)}.\n     */\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) public virtual override {\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        if (id.isFungibleToken()) {\n            _burnFungible(from, id, value, operatable);\n        } else if (id.isNonFungibleToken()) {\n            _burnNFT(from, id, value, operatable, false);\n            emit Transfer(from, address(0), id);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, from, address(0), id, value);\n    }\n\n    /**\n     * Burns a batch of token (ERC1155-compatible).\n     * @dev See {IERC1155721InventoryBurnable-batchBurnFrom(address,uint256[],uint256[])}.\n     */\n    function batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual override {\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        uint256 nftsCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            if (id.isFungibleToken()) {\n                _burnFungible(from, id, values[i], operatable);\n            } else if (id.isNonFungibleToken()) {\n                _burnNFT(from, id, values[i], operatable, true);\n                emit Transfer(from, address(0), id);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n                        nfCollectionId = nextCollectionId;\n                        nftsCount += nfCollectionCount;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n            nftsCount += nfCollectionCount;\n            // cannot underflow as balance is verified through ownership\n            _nftBalances[from] -= nftsCount;\n        }\n\n        emit TransferBatch(sender, from, address(0), ids, values);\n    }\n\n    /**\n     * Burns a batch of token (ERC721-compatible).\n     * @dev See {IERC1155721InventoryBurnable-batchBurnFrom(address,uint256[])}.\n     */\n    function batchBurnFrom(address from, uint256[] memory nftIds) public virtual override {\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            values[i] = 1;\n            _burnNFT(from, nftId, values[i], operatable, true);\n            emit Transfer(from, address(0), nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n            _nftBalances[from] -= length;\n        }\n\n        emit TransferBatch(sender, from, address(0), nftIds, values);\n    }\n\n    //============================== Internal Helper Functions =======================================/\n\n    function _burnFungible(\n        address from,\n        uint256 id,\n        uint256 value,\n        bool operatable\n    ) internal {\n        require(value != 0, \"Inventory: zero value\");\n        require(operatable, \"Inventory: non-approved sender\");\n        uint256 balance = _balances[id][from];\n        require(balance >= value, \"Inventory: not enough balance\");\n        _balances[id][from] = balance - value;\n        // Cannot underflow\n        _supplies[id] -= value;\n    }\n\n    function _burnNFT(\n        address from,\n        uint256 id,\n        uint256 value,\n        bool operatable,\n        bool isBatch\n    ) internal virtual {\n        require(value == 1, \"Inventory: wrong NFT value\");\n        uint256 owner = _owners[id];\n        require(from == address(uint160(owner)), \"Inventory: non-owned NFT\");\n        if (!operatable) {\n            require((owner & _APPROVAL_BIT_TOKEN_OWNER_ != 0) && _msgSender() == _nftApprovals[id], \"Inventory: non-approved sender\");\n        }\n        _owners[id] = _BURNT_NFT_OWNER;\n\n        if (!isBatch) {\n            _burnNFTUpdateCollection(from, id.getNonFungibleCollection(), 1);\n\n            // cannot underflow as balance is verified through NFT ownership\n            --_nftBalances[from];\n        }\n    }\n\n    function _burnNFTUpdateCollection(\n        address from,\n        uint256 collectionId,\n        uint256 amount\n    ) internal virtual {\n        // cannot underflow as balance is verified through NFT ownership\n        _balances[collectionId][from] -= amount;\n        _supplies[collectionId] -= amount;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721InventoryMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title IERC1155721InventoryMintable interface.\n * The function {IERC721Mintable-safeMint(address,uint256,bytes)} is not provided as\n *  {IERC1155Mintable-safeMint(address,uint256,uint256,bytes)} can be used instead.\n */\ninterface IERC1155721InventoryMintable {\n    /**\n     * Safely mints some token (ERC1155-compatible).\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `id` is not a token.\n     * @dev Reverts if `id` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if `id` represents a non-fungible token which has already been minted.\n     * @dev Reverts if `id` represents a fungible token and `value` is 0.\n     * @dev Reverts if `id` represents a fungible token and there is an overflow of supply.\n     * @dev Reverts if `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155Received} fails or is refused.\n     * @dev Emits an {IERC721-Transfer} event from the zero address if `id` represents a non-fungible token.\n     * @dev Emits an {IERC1155-TransferSingle} event from the zero address.\n     * @param to Address of the new token owner.\n     * @param id Identifier of the token to mint.\n     * @param value Amount of token to mint.\n     * @param data Optional data to send along to a receiver contract.\n     */\n    function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * Safely mints a batch of tokens (ERC1155-compatible).\n     * @dev Reverts if `ids` and `values` have different lengths.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if one of `ids` is not a token.\n     * @dev Reverts if one of `ids` represents a non-fungible token and its paired value is not 1.\n     * @dev Reverts if one of `ids` represents a non-fungible token which has already been minted.\n     * @dev Reverts if one of `ids` represents a fungible token and its paired value is 0.\n     * @dev Reverts if one of `ids` represents a fungible token and there is an overflow of supply.\n     * @dev Reverts if `to` is a contract and the call to {IERC1155TokenReceiver-onERC1155batchReceived} fails or is refused.\n     * @dev Emits an {IERC721-Transfer} event from the zero address for each non-fungible token minted.\n     * @dev Emits an {IERC1155-TransferBatch} event from the zero address.\n     * @param to Address of the new tokens owner.\n     * @param ids Identifiers of the tokens to mint.\n     * @param values Amounts of tokens to mint.\n     * @param data Optional data to send along to a receiver contract.\n     */\n    function safeBatchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    /**\n     * Unsafely mints a Non-Fungible Token (ERC721-compatible).\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `nftId` does not represent a non-fungible token.\n     * @dev Reverts if `nftId` has already been minted.\n     * @dev Emits an {IERC721-Transfer} event from the zero address.\n     * @dev Emits an {IERC1155-TransferSingle} event from the zero address.\n     * @dev If `to` is a contract and supports ERC1155TokenReceiver, calls {IERC1155TokenReceiver-onERC1155Received} with empty data.\n     * @param to Address of the new token owner.\n     * @param nftId Identifier of the token to mint.\n     */\n    function mint(address to, uint256 nftId) external;\n\n    /**\n     * Unsafely mints a batch of Non-Fungible Tokens (ERC721-compatible).\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if one of `nftIds` does not represent a non-fungible token.\n     * @dev Reverts if one of `nftIds` has already been minted.\n     * @dev Emits an {IERC721-Transfer} event from the zero address for each of `nftIds`.\n     * @dev Emits an {IERC1155-TransferBatch} event from the zero address.\n     * @dev If `to` is a contract and supports ERC1155TokenReceiver, calls {IERC1155TokenReceiver-onERC1155BatchReceived} with empty data.\n     * @param to Address of the new token owner.\n     * @param nftIds Identifiers of the tokens to mint.\n     */\n    function batchMint(address to, uint256[] calldata nftIds) external;\n\n    /**\n     * Safely mints a token (ERC721-compatible).\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `tokenId` has already ben minted.\n     * @dev Reverts if `to` is a contract which does not implement IERC721Receiver or IERC1155TokenReceiver.\n     * @dev Reverts if `to` is an IERC1155TokenReceiver or IERC721TokenReceiver contract which refuses the transfer.\n     * @dev Emits an {IERC721-Transfer} event from the zero address.\n     * @dev Emits an {IERC1155-TransferSingle} event from the zero address.\n     * @param to Address of the new token owner.\n     * @param nftId Identifier of the token to mint.\n     * @param data Optional data to pass along to the receiver call.\n     */\n    function safeMint(\n        address to,\n        uint256 nftId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721InventoryDeliverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title IERC1155721InventoryDeliverable interface.\n */\ninterface IERC1155721InventoryDeliverable {\n    /**\n     * Safely mints some tokens to a list of recipients.\n     * @dev Reverts if `recipients`, `ids` and `values` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if one of `ids` is not a token.\n     * @dev Reverts if one of `ids` represents a non-fungible token and its `value` is not 1.\n     * @dev Reverts if one of `ids` represents a non-fungible token which has already been minted.\n     * @dev Reverts if one of `ids` represents a fungible token and its `value` is 0.\n     * @dev Reverts if one of `ids` represents a fungible token and there is an overflow of supply.\n     * @dev Reverts if one of `recipients` is a contract and the call to {IERC1155TokenReceiver-onERC1155Received} fails or is refused.\n     * @dev Emits an {IERC721-Transfer} event from the zero address for each `id` representing a non-fungible token.\n     * @dev Emits an {IERC1155-TransferSingle} event from the zero address.\n     * @param recipients Addresses of the new token owners.\n     * @param ids Identifiers of the tokens to mint.\n     * @param values Amounts of tokens to mint.\n     * @param data Optional data to send along to the receiver contract(s), if any. All receivers receive the same data.\n     */\n    function safeDeliver(\n        address[] calldata recipients,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155/IERC1155InventoryCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-1155 Inventory, additional creator interface\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n */\ninterface IERC1155InventoryCreator {\n    /**\n     * Returns the creator of a collection, or the zero address if the collection has not been created.\n     * @dev Reverts if `collectionId` does not represent a collection.\n     * @param collectionId Identifier of the collection.\n     * @return The creator of a collection, or the zero address if the collection has not been created.\n     */\n    function creator(uint256 collectionId) external view returns (address);\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/metadata/BaseMetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity, Ownable} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/access/Ownable.sol\";\nimport {UInt256ToDecimalString} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/UInt256ToDecimalString.sol\";\n\nabstract contract BaseMetadataURI is ManagedIdentity, Ownable {\n    using UInt256ToDecimalString for uint256;\n\n    event BaseMetadataURISet(string baseMetadataURI);\n\n    string public baseMetadataURI;\n\n    function setBaseMetadataURI(string calldata baseMetadataURI_) external {\n        _requireOwnership(_msgSender());\n        baseMetadataURI = baseMetadataURI_;\n        emit BaseMetadataURISet(baseMetadataURI_);\n    }\n\n    function _uri(uint256 id) internal view virtual returns (string memory) {\n        return string(abi.encodePacked(baseMetadataURI, id.toDecimalString()));\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/access/MinterRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * Contract which allows derived contracts access control over token minting operations.\n */\ncontract MinterRole is Ownable {\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    mapping(address => bool) public isMinter;\n\n    /**\n     * Constructor.\n     */\n    constructor(address owner_) Ownable(owner_) {\n        _addMinter(owner_);\n    }\n\n    /**\n     * Grants the minter role to a non-minter.\n     * @dev reverts if the sender is not the contract owner.\n     * @param account The account to grant the minter role to.\n     */\n    function addMinter(address account) public {\n        _requireOwnership(_msgSender());\n        _addMinter(account);\n    }\n\n    /**\n     * Renounces the granted minter role.\n     * @dev reverts if the sender is not a minter.\n     */\n    function renounceMinter() public {\n        address account = _msgSender();\n        _requireMinter(account);\n        isMinter[account] = false;\n        emit MinterRemoved(account);\n    }\n\n    function _requireMinter(address account) internal view {\n        require(isMinter[account], \"MinterRole: not a Minter\");\n    }\n\n    function _addMinter(address account) internal {\n        isMinter[account] = true;\n        emit MinterAdded(account);\n    }\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./UsingAppendedCallData.sol\";\nimport \"./IERC2771.sol\";\nimport \"./IForwarderRegistry.sol\";\n\nabstract contract UsingUniversalForwarding is UsingAppendedCallData, IERC2771 {\n    IForwarderRegistry internal immutable _forwarderRegistry;\n    address internal immutable _universalForwarder;\n\n    constructor(IForwarderRegistry forwarderRegistry, address universalForwarder) {\n        _universalForwarder = universalForwarder;\n        _forwarderRegistry = forwarderRegistry;\n    }\n\n    function isTrustedForwarder(address forwarder) external view virtual override returns (bool) {\n        return forwarder == _universalForwarder || forwarder == address(_forwarderRegistry);\n    }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        address payable msgSender = msg.sender;\n        address payable sender = _lastAppendedDataAsSender();\n        if (msgSender == address(_forwarderRegistry) || msgSender == _universalForwarder) {\n            // if forwarder use appended data\n            return sender;\n        }\n\n        // if msg.sender is neither the registry nor the universal forwarder,\n        // we have to check the last 20bytes of the call data intepreted as an address\n        // and check if the msg.sender was registered as forewarder for that address\n        // we check tx.origin to save gas in case where msg.sender == tx.origin\n        // solhint-disable-next-line avoid-tx-origin\n        if (msgSender != tx.origin && _forwarderRegistry.isForwarderFor(sender, msgSender)) {\n            return sender;\n        }\n\n        return msgSender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        address payable msgSender = msg.sender;\n        if (msgSender == address(_forwarderRegistry) || msgSender == _universalForwarder) {\n            // if forwarder use appended data\n            return _msgDataAssuming20BytesAppendedData();\n        }\n\n        // we check tx.origin to save gas in case where msg.sender == tx.origin\n        // solhint-disable-next-line avoid-tx-origin\n        if (msgSender != tx.origin && _forwarderRegistry.isForwarderFor(_lastAppendedDataAsSender(), msgSender)) {\n            return _msgDataAssuming20BytesAppendedData();\n        }\n        return msg.data;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC1155721/IERC1155721InventoryBurnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title IERC1155721InventoryBurnable interface.\n * The function {IERC721Burnable-burnFrom(address,uint256)} is not provided as\n *  {IERC1155Burnable-burnFrom(address,uint256,uint256)} can be used instead.\n */\ninterface IERC1155721InventoryBurnable {\n    /**\n     * Burns some token (ERC1155-compatible).\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if `id` does not represent a token.\n     * @dev Reverts if `id` represents a fungible token and `value` is 0.\n     * @dev Reverts if `id` represents a fungible token and `value` is higher than `from`'s balance.\n     * @dev Reverts if `id` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if `id` represents a non-fungible token which is not owned by `from`.\n     * @dev Emits an {IERC721-Transfer} event to the zero address if `id` represents a non-fungible token.\n     * @dev Emits an {IERC1155-TransferSingle} event to the zero address.\n     * @param from Address of the current token owner.\n     * @param id Identifier of the token to burn.\n     * @param value Amount of token to burn.\n     */\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) external;\n\n    /**\n     * Burns multiple tokens (ERC1155-compatible).\n     * @dev Reverts if `ids` and `values` have different lengths.\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if one of `ids` does not represent a token.\n     * @dev Reverts if one of `ids` represents a fungible token and `value` is 0.\n     * @dev Reverts if one of `ids` represents a fungible token and `value` is higher than `from`'s balance.\n     * @dev Reverts if one of `ids` represents a non-fungible token and `value` is not 1.\n     * @dev Reverts if one of `ids` represents a non-fungible token which is not owned by `from`.\n     * @dev Emits an {IERC721-Transfer} event to the zero address for each burnt non-fungible token.\n     * @dev Emits an {IERC1155-TransferBatch} event to the zero address.\n     * @param from Address of the current tokens owner.\n     * @param ids Identifiers of the tokens to burn.\n     * @param values Amounts of tokens to burn.\n     */\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) external;\n\n    /**\n     * Burns a batch of Non-Fungible Tokens (ERC721-compatible).\n     * @dev Reverts if the sender is not approved.\n     * @dev Reverts if one of `nftIds` does not represent a non-fungible token.\n     * @dev Reverts if one of `nftIds` is not owned by `from`.\n     * @dev Emits an {IERC721-Transfer} event to the zero address for each of `nftIds`.\n     * @dev Emits an {IERC1155-TransferBatch} event to the zero address.\n     * @param from Current token owner.\n     * @param nftIds Identifiers of the tokens to transfer.\n     */\n    function batchBurnFrom(address from, uint256[] calldata nftIds) external;\n}\n"
    },
    "@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/UInt256ToDecimalString.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Partially derived from OpenZeppelin:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8b10cb38d8fedf34f2d89b0ed604f2dceb76d6a9/contracts/utils/Strings.sol\n\npragma solidity >=0.7.6 <0.8.0;\n\nlibrary UInt256ToDecimalString {\n    function toDecimalString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingAppendedCallData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nabstract contract UsingAppendedCallData {\n    function _lastAppendedDataAsSender() internal pure virtual returns (address payable sender) {\n        // Copied from openzeppelin : https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9d5f77db9da0604ce0b25148898a94ae2c20d70f/contracts/metatx/ERC2771Context.sol1\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n\n    function _msgDataAssuming20BytesAppendedData() internal pure virtual returns (bytes calldata) {\n        return msg.data[:msg.data.length - 20];\n    }\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/IERC2771.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC2771 {\n    function isTrustedForwarder(address forwarder) external view returns (bool);\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IForwarderRegistry {\n    function isForwarderFor(address, address) external view returns (bool);\n}\n"
    },
    "contracts/token/ERC20/PolygonREVV.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IWrappedERC20, ERC20Wrapper} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/ERC20Wrapper.sol\";\nimport {ManagedIdentity, Ownable, Recoverable} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/Recoverable.sol\";\nimport {ChildERC20} from \"@animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ChildERC20.sol\";\nimport {IForwarderRegistry, UsingUniversalForwarding} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol\";\n\ncontract PolygonREVV is Recoverable, UsingUniversalForwarding, ChildERC20 {\n    using ERC20Wrapper for IWrappedERC20;\n\n    uint256 public escrowed;\n\n    constructor(\n        uint256 supply,\n        address childChainManager,\n        IForwarderRegistry forwarderRegistry,\n        address universalForwarder\n    ) ChildERC20(\"REVV\", \"REVV\", 18, \"\", childChainManager) UsingUniversalForwarding(forwarderRegistry, universalForwarder) Ownable(msg.sender) {\n        _mint(address(this), supply);\n        escrowed = supply;\n    }\n\n    function setTokenURI(string memory tokenURI_) external {\n        _requireOwnership(_msgSender());\n        _tokenURI = tokenURI_;\n    }\n\n    function deposit(address user, bytes calldata depositData) public virtual override {\n        escrowed -= abi.decode(depositData, (uint256));\n        super.deposit(user, depositData);\n    }\n\n    function withdraw(uint256 amount) public virtual override {\n        escrowed += amount;\n        super.withdraw(amount);\n    }\n\n    function onERC20Received(\n        address operator,\n        address from,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bytes4) {\n        escrowed += amount;\n        return super.onERC20Received(operator, from, amount, data);\n    }\n\n    function recoverERC20s(\n        address[] calldata accounts,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external virtual override {\n        _requireOwnership(_msgSender());\n        uint256 length = accounts.length;\n        require(length == tokens.length && length == amounts.length, \"Recov: inconsistent arrays\");\n        for (uint256 i = 0; i != length; ++i) {\n            address token = tokens[i];\n            uint256 amount = amounts[i];\n            if (token == address(this)) {\n                uint256 recoverable = _balances[address(this)] - escrowed;\n                require(amount <= recoverable, \"Recov: insufficient balance\");\n            }\n            IWrappedERC20(token).wrappedTransfer(accounts[i], amount);\n        }\n    }\n\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\n        return UsingUniversalForwarding._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\n        return UsingUniversalForwarding._msgData();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
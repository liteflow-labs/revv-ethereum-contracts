{
  "language": "Solidity",
  "sources": {
    "contracts/token/ERC20/CatalystBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC20Receiver} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Receiver.sol\";\nimport {IERC20Burnable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Burnable.sol\";\nimport {IERC20Mintable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Mintable.sol\";\nimport {ERC20Receiver} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20Receiver.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol\";\nimport {Recoverable} from \"@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol\";\n\n/**\n * @title REVV Racing Catalysts Builder which converts SHRD into CATA.\n */\ncontract REVVRacingCatalystBuilder is ERC20Receiver, MinterRole, Recoverable {\n    event ConversionRateUpdated(uint256 conversionRate);\n\n    IERC20Burnable public immutable shards;\n    IERC20Mintable public immutable catalysts;\n\n    uint256 public conversionRate; // number of shard necessary to build a catalyst\n\n    constructor(IERC20Burnable shards_, IERC20Mintable catalysts_) MinterRole(msg.sender) {\n        shards = shards_;\n        catalysts = catalysts_;\n        emit ConversionRateUpdated(0);\n    }\n\n    //==================================================== ERC20Receiver ====================================================//\n\n    /**\n     * On safe reception of shards, converts them into catalysts based on the current conversion rate.\n     * @dev Reverts if the sender is not the shards contract.\n     * @dev Reverts if the conversion rate is currently set to zero.\n     * @inheritdoc IERC20Receiver\n     */\n    function onERC20Received(\n        address, /*sender,*/\n        address from,\n        uint256 value,\n        bytes memory /*data*/\n    ) public virtual override returns (bytes4) {\n        require(msg.sender == address(shards), \"CatalystBuilder: wrong sender\");\n\n        uint256 rate = conversionRate;\n        require(rate != 0, \"CatalystBuilder: rate not set\");\n\n        shards.burn(value);\n        catalysts.mint(from, value / rate);\n\n        return _ERC20_RECEIVED;\n    }\n\n    //=================================================== CatalystBuilder ===================================================//\n\n    /**\n     * Sets the conversion rate.\n     * @dev Reverts if not sent by a minter.\n     * @dev Emits a ConversionRateUpdated event.\n     * @param conversionRate_ the new conversion rate. A zero value disables the conversion.\n     */\n    function setConversionRate(uint256 conversionRate_) external {\n        _requireMinter(_msgSender());\n        conversionRate = conversionRate_;\n        emit ConversionRateUpdated(conversionRate_);\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, Tokens Receiver.\n * Interface for any contract that wants to support safeTransfers from ERC20 contracts with Safe Transfers extension.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: the ERC-165 identifier for this interface is 0x4fc35859.\n */\ninterface IERC20Receiver {\n    /**\n     * Handles the receipt of ERC20 tokens.\n     * @param sender The initiator of the transfer.\n     * @param from The address which transferred the tokens.\n     * @param value The amount of tokens transferred.\n     * @param data Optional additional data with no specified format.\n     * @return bytes4 `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC20Received(\n        address sender,\n        address from,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Burnable.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: the ERC-165 identifier for this interface is 0x3b5a0bf8.\n */\ninterface IERC20Burnable {\n    /**\n     * Burns `value` tokens from the message sender, decreasing the total supply.\n     * @dev Reverts if the sender owns less than `value` tokens.\n     * @dev Emits a {IERC20-Transfer} event with `_to` set to the zero address.\n     * @param value the amount of tokens to burn.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function burn(uint256 value) external returns (bool);\n\n    /**\n     * Burns `value` tokens from `from`, using the allowance mechanism and decreasing the total supply.\n     * @dev Reverts if `from` owns less than `value` tokens.\n     * @dev Reverts if `from` is not the sender and the sender is not approved by `from` for at least `value` tokens.\n     * @dev Emits a {IERC20-Transfer} event with `_to` set to the zero address.\n     * @dev Emits a {IERC20-Approval} event if `from` is not the sender (non-standard).\n     * @param from the account to burn the tokens from.\n     * @param value the amount of tokens to burn.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function burnFrom(address from, uint256 value) external returns (bool);\n\n    /**\n     * Burns `values` tokens from `owners`, decreasing the total supply.\n     * @dev Reverts if one `owners` and `values` have different lengths.\n     * @dev Reverts if one of `owners` owns less than the corresponding `value` tokens.\n     * @dev Reverts if one of `owners` is not the sender and the sender is not approved the corresponding `owner` and `value`.\n     * @dev Emits a {IERC20-Transfer} event with `_to` set to the zero address.\n     * @dev Emits a {IERC20-Approval} event (non-standard).\n     * @param owners the accounts to burn the tokens from.\n     * @param values the amounts of tokens to burn.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function batchBurnFrom(address[] calldata owners, uint256[] calldata values) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Mintable.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20Mintable {\n    /**\n     * Mints `value` tokens and assigns them to `to`, increasing the total supply.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the total supply overflows.\n     * @dev Emits a {IERC20-Transfer} event with `from` set to the zero address.\n     * @param to the account to deliver the tokens to.\n     * @param value the amount of tokens to mint.\n     */\n    function mint(address to, uint256 value) external;\n\n    /**\n     * Mints `values` tokens and assigns them to `recipients`, increasing the total supply.\n     * @dev Reverts if `recipients` and `values` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if the total supply overflows.\n     * @dev Emits an {IERC20-Transfer} event for each transfer with `_from` set to the zero address.\n     * @param recipients the accounts to deliver the tokens to.\n     * @param values the amounts of tokens to mint to each of `recipients`.\n     */\n    function batchMint(address[] calldata recipients, uint256[] calldata values) external;\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC165} from \"@animoca/ethereum-contracts-core/contracts/introspection/IERC165.sol\";\nimport {IERC20Receiver} from \"./interfaces/IERC20Receiver.sol\";\n\n/**\n * @title ERC20 Safe Transfers Receiver Contract.\n * @dev The function `onERC20Received(address,address,uint256,bytes)` needs to be implemented by a child contract.\n */\nabstract contract ERC20Receiver is IERC20Receiver, IERC165 {\n    bytes4 internal constant _ERC20_RECEIVED = type(IERC20Receiver).interfaceId;\n    bytes4 internal constant _ERC20_REJECTED = 0xffffffff;\n\n    //======================================================= ERC165 ========================================================//\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC20Receiver).interfaceId;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * Contract which allows derived contracts access control over token minting operations.\n */\ncontract MinterRole is Ownable {\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    mapping(address => bool) public isMinter;\n\n    /**\n     * Constructor.\n     */\n    constructor(address owner_) Ownable(owner_) {\n        _addMinter(owner_);\n    }\n\n    /**\n     * Grants the minter role to a non-minter.\n     * @dev reverts if the sender is not the contract owner.\n     * @param account The account to grant the minter role to.\n     */\n    function addMinter(address account) public {\n        _requireOwnership(_msgSender());\n        _addMinter(account);\n    }\n\n    /**\n     * Renounces the granted minter role.\n     * @dev reverts if the sender is not a minter.\n     */\n    function renounceMinter() public {\n        address account = _msgSender();\n        _requireMinter(account);\n        isMinter[account] = false;\n        emit MinterRemoved(account);\n    }\n\n    function _requireMinter(address account) internal view {\n        require(isMinter[account], \"MinterRole: not a Minter\");\n    }\n\n    function _addMinter(address account) internal {\n        isMinter[account] = true;\n        emit MinterAdded(account);\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"../metatx/ManagedIdentity.sol\";\nimport {Ownable} from \"../access/Ownable.sol\";\nimport {IWrappedERC20, ERC20Wrapper} from \"./ERC20Wrapper.sol\";\n\nabstract contract Recoverable is ManagedIdentity, Ownable {\n    using ERC20Wrapper for IWrappedERC20;\n\n    /**\n     * Extract ERC20 tokens which were accidentally sent to the contract to a list of accounts.\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC20 tokens\n     * so that the extraction is limited to only amounts sent accidentally.\n     * @dev Reverts if the sender is not the contract owner.\n     * @dev Reverts if `accounts`, `tokens` and `amounts` do not have the same length.\n     * @dev Reverts if one of `tokens` is does not implement the ERC20 transfer function.\n     * @dev Reverts if one of the ERC20 transfers fail for any reason.\n     * @param accounts the list of accounts to transfer the tokens to.\n     * @param tokens the list of ERC20 token addresses.\n     * @param amounts the list of token amounts to transfer.\n     */\n    function recoverERC20s(\n        address[] calldata accounts,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external virtual {\n        _requireOwnership(_msgSender());\n        uint256 length = accounts.length;\n        require(length == tokens.length && length == amounts.length, \"Recov: inconsistent arrays\");\n        for (uint256 i = 0; i != length; ++i) {\n            IWrappedERC20(tokens[i]).wrappedTransfer(accounts[i], amounts[i]);\n        }\n    }\n\n    /**\n     * Extract ERC721 tokens which were accidentally sent to the contract to a list of accounts.\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC721 tokens\n     * so that the extraction is limited to only tokens sent accidentally.\n     * @dev Reverts if the sender is not the contract owner.\n     * @dev Reverts if `accounts`, `contracts` and `amounts` do not have the same length.\n     * @dev Reverts if one of `contracts` is does not implement the ERC721 transferFrom function.\n     * @dev Reverts if one of the ERC721 transfers fail for any reason.\n     * @param accounts the list of accounts to transfer the tokens to.\n     * @param contracts the list of ERC721 contract addresses.\n     * @param tokenIds the list of token ids to transfer.\n     */\n    function recoverERC721s(\n        address[] calldata accounts,\n        address[] calldata contracts,\n        uint256[] calldata tokenIds\n    ) external virtual {\n        _requireOwnership(_msgSender());\n        uint256 length = accounts.length;\n        require(length == contracts.length && length == tokenIds.length, \"Recov: inconsistent arrays\");\n        for (uint256 i = 0; i != length; ++i) {\n            IRecoverableERC721(contracts[i]).transferFrom(address(this), accounts[i], tokenIds[i]);\n        }\n    }\n}\n\ninterface IRecoverableERC721 {\n    /// See {IERC721-transferFrom(address,address,uint256)}\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {ManagedIdentity} from \"../metatx/ManagedIdentity.sol\";\nimport {IERC173} from \"./IERC173.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is ManagedIdentity, IERC173 {\n    address internal _owner;\n\n    /**\n     * Initializes the contract, setting the deployer as the initial owner.\n     * @dev Emits an {IERC173-OwnershipTransferred(address,address)} event.\n     */\n    constructor(address owner_) {\n        _owner = owner_;\n        emit OwnershipTransferred(address(0), owner_);\n    }\n\n    /**\n     * Gets the address of the current contract owner.\n     */\n    function owner() public view virtual override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * See {IERC173-transferOwnership(address)}\n     * @dev Reverts if the sender is not the current contract owner.\n     * @param newOwner the address of the new owner. Use the zero address to renounce the ownership.\n     */\n    function transferOwnership(address newOwner) public virtual override {\n        _requireOwnership(_msgSender());\n        _owner = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n\n    /**\n     * @dev Reverts if `account` is not the contract owner.\n     * @param account the account to test.\n     */\n    function _requireOwnership(address account) internal virtual {\n        require(account == this.owner(), \"Ownable: not the owner\");\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/*\n * Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner.\n */\nabstract contract ManagedIdentity {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        return msg.data;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC-173 Contract Ownership Standard\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\n */\ninterface IERC173 {\n    /**\n     * Event emited when ownership of a contract changes.\n     * @param previousOwner the previous owner.\n     * @param newOwner the new owner.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * Get the address of the owner\n     * @return The address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * Set the address of the new owner of the contract\n     * Set newOwner to address(0) to renounce any ownership.\n     * @dev Emits an {OwnershipTransferred} event.\n     * @param newOwner The address of the new owner of the contract. Using the zero address means renouncing ownership.\n     */\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/utils/ERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {AddressIsContract} from \"./types/AddressIsContract.sol\";\n\n/**\n * @title ERC20Wrapper\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\n * Calls to the wrapped functions revert only if they throw or if they return false.\n */\nlibrary ERC20Wrapper {\n    using AddressIsContract for address;\n\n    function wrappedTransfer(\n        IWrappedERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function wrappedTransferFrom(\n        IWrappedERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function wrappedApprove(\n        IWrappedERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\n        address target = address(token);\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = target.call(callData);\n        if (success) {\n            if (data.length != 0) {\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\n            }\n        } else {\n            // revert using a standard revert message\n            if (data.length == 0) {\n                revert(\"ERC20Wrapper: operation failed\");\n            }\n\n            // revert using the revert message coming from the call\n            assembly {\n                let size := mload(data)\n                revert(add(32, data), size)\n            }\n        }\n    }\n}\n\ninterface IWrappedERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-core/contracts/utils/types/AddressIsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Partially derived from OpenZeppelin:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @dev Upgrades the address type to check if it is a contract.\n */\nlibrary AddressIsContract {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/token/fusion/ChassisCounters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {Recoverable} from \"@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol\";\nimport {IChassisCounters} from \"./interfaces/IChassisCounters.sol\";\n\ncontract ChassisCounters is IChassisCounters, Recoverable, MinterRole {\n    mapping(uint256 => uint256) public counters;\n\n    constructor() MinterRole(msg.sender) {}\n\n    function incrementCounter(uint256 tokenType) external override returns (uint256) {\n        _requireMinter(msg.sender);\n        return ++counters[tokenType];\n    }\n}\n"
    },
    "contracts/token/fusion/interfaces/IChassisCounters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\ninterface IChassisCounters {\n    function incrementCounter(uint256 tokenType) external returns (uint256);\n}\n"
    },
    "contracts/token/fusion/facets/FusionFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {LibDiamond} from \"hardhat-deploy/solc_0.7/diamond/libraries/LibDiamond.sol\";\nimport {LibFusion} from \"./../libraries/LibFusion.sol\";\nimport {IREVVRacingCar} from \"./../interfaces/IREVVRacingCar.sol\";\nimport {IREVVMotorsportCatalyst} from \"./../interfaces/IREVVMotorsportCatalyst.sol\";\nimport {IREVV} from \"./../interfaces/IREVV.sol\";\nimport {IChassisCounters} from \"./../interfaces/IChassisCounters.sol\";\nimport {IERC1155TokenReceiver} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC1155/interfaces/IERC1155TokenReceiver.sol\";\n\ncontract FusionFacet is IERC1155TokenReceiver {\n    function initFusionStorage(\n        IREVVRacingCar cars_,\n        IREVVMotorsportCatalyst catalysts_,\n        IREVV revv_,\n        IChassisCounters counters_,\n        address payoutWallet_,\n        address yard_\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC1155TokenReceiver).interfaceId] = true;\n\n        LibFusion.initFusionStorage(cars_, catalysts_, revv_, counters_, payoutWallet_, yard_);\n    }\n\n    //================================================ ERC1155TokenReceiver =================================================//\n\n    /**\n     * Handle the fusion request of a single REVV Racing token.\n     * @dev Reverts if the blueprint identifier encoded in `data` is not set.\n     * param operator  The address which initiated the transfer (i.e. msg.sender)\n     * param from      The address which previously owned the token\n     * param id        The ID of the token being transferred\n     * param value     The amount of tokens being transferred\n     * @param data     The abi-encoded blueprint identifier.\n     * @return         `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     */\n    function onERC1155Received(\n        address, /*operator,*/\n        address, /*from,*/\n        uint256, /*id,*/\n        uint256, /*value,*/\n        bytes calldata data\n    ) external override returns (bytes4) {\n        return _delegateFusionCall(abi.decode(data, (uint256)));\n    }\n\n    /**\n     * Handle the fusion request of multiple REVV Racing tokens.\n     * @dev Reverts if the blueprint identifier encoded in `data` is not set.\n     * param operator  The address which initiated the batch transfer (i.e. msg.sender)\n     * param from      The address which previously owned the token\n     * param ids       An array containing ids of each token being transferred (order and length must match values array)\n     * param values    An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data     The abi-encoded blueprint identifier.\n     * @return         `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     */\n    function onERC1155BatchReceived(\n        address, /*operator,*/\n        address, /*from,*/\n        uint256[] calldata, /*ids,*/\n        uint256[] calldata, /*values,*/\n        bytes calldata data\n    ) external override returns (bytes4) {\n        return _delegateFusionCall(abi.decode(data, (uint256)));\n    }\n\n    //=============================================== Public Admin Functions ================================================//\n\n    function setBlueprint(uint256 blueprintId, address blueprint_) external {\n        LibDiamond.enforceIsContractOwner();\n        LibFusion.setBlueprint(blueprintId, blueprint_);\n    }\n\n    function setPayoutWallet(address payoutWallet_) external {\n        LibDiamond.enforceIsContractOwner();\n        LibFusion.setPayoutWallet(payoutWallet_);\n    }\n\n    //=================================================== Public Getters ====================================================//\n\n    function blueprint(uint256 blueprintId) external view returns (address) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.blueprints[blueprintId];\n    }\n\n    function payoutWallet() external view returns (address) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.payoutWallet;\n    }\n\n    function cars() external view returns (IREVVRacingCar) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.cars;\n    }\n\n    function revv() external view returns (IREVV) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.revv;\n    }\n\n    function catalysts() external view returns (IREVVMotorsportCatalyst) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.catalysts;\n    }\n\n    function yard() external view returns (address) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.yard;\n    }\n\n    function counters() external view returns (IChassisCounters) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        return fs.counters;\n    }\n\n    //============================================== Helper Internal Functions ==============================================//\n\n    function _delegateFusionCall(uint256 blueprintId) internal returns (bytes4) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        address blueprintAddress = fs.blueprints[blueprintId];\n        require(blueprintAddress != address(0), \"Fusion: non-existent blueprint\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the blueprint\n            let result := delegatecall(gas(), blueprintAddress, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.7/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n            ds.facetAddresses.push(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\n            ds.facetAddresses.push(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            // add function\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/token/fusion/libraries/LibFusion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IREVVRacingCar} from \"./../interfaces/IREVVRacingCar.sol\";\nimport {IREVVMotorsportCatalyst} from \"./../interfaces/IREVVMotorsportCatalyst.sol\";\nimport {IREVV} from \"./../interfaces/IREVV.sol\";\nimport {IChassisCounters} from \"./../interfaces/IChassisCounters.sol\";\n\nlibrary LibFusion {\n    bytes32 public constant FUSION_STORAGE_POSITION = keccak256(\"revvracing.fusion.storage\");\n\n    struct FusionStorage {\n        bool initialised;\n        // Blueprint contract addresses\n        mapping(uint256 => address) blueprints;\n        // Tokens for fusion\n        IREVVRacingCar cars;\n        IREVVMotorsportCatalyst catalysts;\n        IREVV revv;\n        // Minting counters\n        IChassisCounters counters;\n        // Recipients\n        address payoutWallet;\n        address yard;\n    }\n\n    function fusionStorage() internal pure returns (FusionStorage storage fs) {\n        bytes32 position = FUSION_STORAGE_POSITION;\n        assembly {\n            fs.slot := position\n        }\n    }\n\n    function initFusionStorage(\n        IREVVRacingCar cars_,\n        IREVVMotorsportCatalyst catalysts_,\n        IREVV revv_,\n        IChassisCounters counters_,\n        address payoutWallet_,\n        address yard_\n    ) internal {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        require(!fs.initialised, \"Fusion: storage initialised\");\n        fs.initialised = true;\n        fs.cars = cars_;\n        fs.catalysts = catalysts_;\n        fs.revv = revv_;\n        fs.counters = counters_;\n        fs.payoutWallet = payoutWallet_;\n        fs.yard = yard_;\n    }\n\n    function setBlueprint(uint256 blueprintId, address blueprintAddress) internal {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        fs.blueprints[blueprintId] = blueprintAddress;\n    }\n\n    function setPayoutWallet(address payoutWallet) internal {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        fs.payoutWallet = payoutWallet;\n    }\n}\n"
    },
    "contracts/token/fusion/interfaces/IREVVRacingCar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\ninterface IREVVRacingCar {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n\n    function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    function safeBatchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/token/fusion/interfaces/IREVVMotorsportCatalyst.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\ninterface IREVVMotorsportCatalyst {\n    function burnFrom(address from, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/token/fusion/interfaces/IREVV.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\ninterface IREVV {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC1155/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC1155 Multi Token Standard, Tokens Receiver.\n * Interface for any contract that wants to support transfers from ERC1155 asset contracts.\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\n * @dev Note: The ERC-165 identifier for this interface is 0x4e2312e0.\n */\ninterface IERC1155TokenReceiver {\n    /**\n     * @notice Handle the receipt of a single ERC1155 token type.\n     * An ERC1155 contract MUST call this function on a recipient contract, at the end of a `safeTransferFrom` after the balance update.\n     * This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     *  (i.e. 0xf23a6e61) to accept the transfer.\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n     * @param operator  The address which initiated the transfer (i.e. msg.sender)\n     * @param from      The address which previously owned the token\n     * @param id        The ID of the token being transferred\n     * @param value     The amount of tokens being transferred\n     * @param data      Additional data with no specified format\n     * @return bytes4   `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice Handle the receipt of multiple ERC1155 token types.\n     * An ERC1155 contract MUST call this function on a recipient contract, at the end of a `safeBatchTransferFrom` after the balance updates.\n     * This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     *  (i.e. 0xbc197c81) if to accept the transfer(s).\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\n     * @param operator  The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from      The address which previously owned the token\n     * @param ids       An array containing ids of each token being transferred (order and length must match _values array)\n     * @param values    An array containing amounts of each token being transferred (order and length must match _ids array)\n     * @param data      Additional data with no specified format\n     * @return          `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "hardhat-deploy/solc_0.7/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/token/fusion/blueprints/BlueprintBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC1155TokenReceiver} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC1155/interfaces/IERC1155TokenReceiver.sol\";\n\nabstract contract BlueprintBase is IERC1155TokenReceiver {\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant _ERC1155_RECEIVED = 0xf23a6e61;\n\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant _ERC1155_BATCH_RECEIVED = 0xbc197c81;\n}\n"
    },
    "contracts/token/fusion/blueprints/BlueprintB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IREVVRacingCar, LibFusion} from \"./../libraries/LibFusion.sol\";\nimport {BlueprintBase} from \"./BlueprintBase.sol\";\n\ncontract BlueprintB is BlueprintBase {\n    uint256 public immutable spentTokenMask1;\n    uint256 public immutable spentTokenMask2;\n    uint256 public immutable deliveredTokenMask;\n    uint256 public immutable catalystCost;\n    uint256 public immutable revvCost;\n\n    constructor(\n        uint256 spentTokenMask1_,\n        uint256 spentTokenMask2_,\n        uint256 deliveredTokenMask_,\n        uint256 catalystCost_,\n        uint256 revvCost_\n    ) {\n        spentTokenMask1 = spentTokenMask1_;\n        spentTokenMask2 = spentTokenMask2_;\n        deliveredTokenMask = deliveredTokenMask_;\n        catalystCost = catalystCost_;\n        revvCost = revvCost_;\n    }\n\n    //================================================ ERC1155TokenReceiver =================================================//\n\n    function onERC1155Received(\n        address, /*operator,*/\n        address, /*from,*/\n        uint256, /*id,*/\n        uint256, /*value,*/\n        bytes calldata /*data*/\n    ) external pure override returns (bytes4) {\n        revert(\"Fusion: unsupported call\");\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator,*/\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata /*data*/\n    ) external override returns (bytes4) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        IREVVRacingCar cars = fs.cars;\n        require(msg.sender == address(cars), \"Fusion: wrong sender\");\n        require(ids.length == 2, \"Fusion: incorrect length\");\n        require(ids[0] & spentTokenMask1 == spentTokenMask1, \"Fusion: wrong token1 type\");\n        require(ids[1] & spentTokenMask2 == spentTokenMask2, \"Fusion: wrong token2 type\");\n        fs.catalysts.burnFrom(from, catalystCost);\n        fs.revv.transferFrom(from, fs.payoutWallet, revvCost);\n        cars.safeBatchTransferFrom(address(this), fs.yard, ids, values, \"\");\n        cars.safeMint(from, deliveredTokenMask | fs.counters.incrementCounter(deliveredTokenMask), 1, \"\");\n        return _ERC1155_BATCH_RECEIVED;\n    }\n}\n"
    },
    "contracts/token/fusion/blueprints/BlueprintA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IREVVRacingCar, LibFusion} from \"./../libraries/LibFusion.sol\";\nimport {BlueprintBase} from \"./BlueprintBase.sol\";\n\ncontract BlueprintA is BlueprintBase {\n    uint256 public immutable spentTokenMask;\n    uint256 public immutable deliveredTokenMask;\n    uint256 public immutable catalystCost;\n    uint256 public immutable revvCost;\n\n    constructor(\n        uint256 spentTokenMask_,\n        uint256 deliveredTokenMask_,\n        uint256 catalystCost_,\n        uint256 revvCost_\n    ) {\n        spentTokenMask = spentTokenMask_;\n        deliveredTokenMask = deliveredTokenMask_;\n        catalystCost = catalystCost_;\n        revvCost = revvCost_;\n    }\n\n    //================================================ ERC1155TokenReceiver =================================================//\n\n    function onERC1155Received(\n        address, /*operator,*/\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata /*data*/\n    ) external override returns (bytes4) {\n        LibFusion.FusionStorage storage fs = LibFusion.fusionStorage();\n        IREVVRacingCar cars = fs.cars;\n        require(msg.sender == address(cars), \"Fusion: wrong sender\");\n        require(id & spentTokenMask == spentTokenMask, \"Fusion: wrong token type\");\n        fs.catalysts.burnFrom(from, catalystCost);\n        fs.revv.transferFrom(from, fs.payoutWallet, revvCost);\n        cars.safeTransferFrom(address(this), fs.yard, id, value, \"\");\n        cars.safeMint(from, deliveredTokenMask | fs.counters.incrementCounter(deliveredTokenMask), value, \"\");\n\n        return _ERC1155_RECEIVED;\n    }\n\n    function onERC1155BatchReceived(\n        address, /*operator,*/\n        address, /*from,*/\n        uint256[] calldata, /*ids,*/\n        uint256[] calldata, /*values,*/\n        bytes calldata /*data*/\n    ) external pure override returns (bytes4) {\n        revert(\"Fusion: unsupported call\");\n    }\n}\n"
    },
    "contracts/token/ERC20/REVVRacingCatalyst.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {IERC20Mintable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Mintable.sol\";\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol\";\nimport {Recoverable} from \"@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol\";\nimport {UsingUniversalForwarding} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol\";\nimport {ERC20Burnable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20Burnable.sol\";\n\n/**\n * @title REVV Racing Catalysts Token.\n */\ncontract REVVRacingCatalyst is Recoverable, UsingUniversalForwarding, ERC20Burnable, IERC20Mintable, MinterRole {\n    constructor(IForwarderRegistry forwarderRegistry)\n        ERC20Burnable(\"REVV Racing Catalyst\", \"CATA\", 18)\n        MinterRole(msg.sender)\n        UsingUniversalForwarding(forwarderRegistry, address(0))\n    {}\n\n    //================================================ ERC20Metadata (admin) ================================================//\n\n    /**\n     * Sets the token metadata URI.\n     * @dev Reverts if not called by the contract owner.\n     * @param tokenURI_ the new token metadata URI.\n     */\n    function setTokenURI(string calldata tokenURI_) external {\n        _requireOwnership(_msgSender());\n        _tokenURI = tokenURI_;\n    }\n\n    //================================================ ERC20Mintable (admin) ================================================//\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function mint(address to, uint256 value) public virtual override {\n        _requireMinter(_msgSender());\n        _mint(to, value);\n    }\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function batchMint(address[] memory recipients, uint256[] memory values) public virtual override {\n        _requireMinter(_msgSender());\n        _batchMint(recipients, values);\n    }\n\n    //======================================== Meta Transactions Internal Functions =========================================//\n\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\n        return UsingUniversalForwarding._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\n        return UsingUniversalForwarding._msgData();\n    }\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IForwarderRegistry {\n    function isForwarderFor(address, address) external view returns (bool);\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./UsingAppendedCallData.sol\";\nimport \"./IERC2771.sol\";\nimport \"./IForwarderRegistry.sol\";\n\nabstract contract UsingUniversalForwarding is UsingAppendedCallData, IERC2771 {\n    IForwarderRegistry internal immutable _forwarderRegistry;\n    address internal immutable _universalForwarder;\n\n    constructor(IForwarderRegistry forwarderRegistry, address universalForwarder) {\n        _universalForwarder = universalForwarder;\n        _forwarderRegistry = forwarderRegistry;\n    }\n\n    function isTrustedForwarder(address forwarder) external view virtual override returns (bool) {\n        return forwarder == _universalForwarder || forwarder == address(_forwarderRegistry);\n    }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        address payable msgSender = msg.sender;\n        address payable sender = _lastAppendedDataAsSender();\n        if (msgSender == address(_forwarderRegistry) || msgSender == _universalForwarder) {\n            // if forwarder use appended data\n            return sender;\n        }\n\n        // if msg.sender is neither the registry nor the universal forwarder,\n        // we have to check the last 20bytes of the call data intepreted as an address\n        // and check if the msg.sender was registered as forewarder for that address\n        // we check tx.origin to save gas in case where msg.sender == tx.origin\n        // solhint-disable-next-line avoid-tx-origin\n        if (msgSender != tx.origin && _forwarderRegistry.isForwarderFor(sender, msgSender)) {\n            return sender;\n        }\n\n        return msgSender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        address payable msgSender = msg.sender;\n        if (msgSender == address(_forwarderRegistry) || msgSender == _universalForwarder) {\n            // if forwarder use appended data\n            return _msgDataAssuming20BytesAppendedData();\n        }\n\n        // we check tx.origin to save gas in case where msg.sender == tx.origin\n        // solhint-disable-next-line avoid-tx-origin\n        if (msgSender != tx.origin && _forwarderRegistry.isForwarderFor(_lastAppendedDataAsSender(), msgSender)) {\n            return _msgDataAssuming20BytesAppendedData();\n        }\n        return msg.data;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC165} from \"@animoca/ethereum-contracts-core/contracts/introspection/IERC165.sol\";\nimport {IERC20Burnable} from \"./interfaces/IERC20Burnable.sol\";\nimport {ERC20} from \"./ERC20.sol\";\n\n/**\n * @title ERC20 Fungible Token Contract, Burnable version.\n */\ncontract ERC20Burnable is ERC20, IERC20Burnable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ERC20(name, symbol, decimals) {}\n\n    //======================================================= ERC165 ========================================================//\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC20Burnable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    //==================================================== ERC20Burnable ====================================================//\n\n    /// @inheritdoc IERC20Burnable\n    function burn(uint256 amount) external virtual override returns (bool) {\n        _burn(_msgSender(), amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC20Burnable\n    function burnFrom(address from, uint256 value) external virtual override returns (bool) {\n        _burnFrom(from, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20Burnable\n    function batchBurnFrom(address[] calldata owners, uint256[] calldata values) external virtual override returns (bool) {\n        _batchBurnFrom(owners, values);\n        return true;\n    }\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingAppendedCallData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nabstract contract UsingAppendedCallData {\n    function _lastAppendedDataAsSender() internal pure virtual returns (address payable sender) {\n        // Copied from openzeppelin : https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9d5f77db9da0604ce0b25148898a94ae2c20d70f/contracts/metatx/ERC2771Context.sol1\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n\n    function _msgDataAssuming20BytesAppendedData() internal pure virtual returns (bytes calldata) {\n        return msg.data[:msg.data.length - 20];\n    }\n}\n"
    },
    "ethereum-universal-forwarder/src/solc_0.7/ERC2771/IERC2771.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC2771 {\n    function isTrustedForwarder(address forwarder) external view returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {AddressIsContract} from \"@animoca/ethereum-contracts-core/contracts/utils/types/AddressIsContract.sol\";\nimport {IERC165} from \"@animoca/ethereum-contracts-core/contracts/introspection/IERC165.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IERC20Detailed} from \"./interfaces/IERC20Detailed.sol\";\nimport {IERC20Allowance} from \"./interfaces/IERC20Allowance.sol\";\nimport {IERC20SafeTransfers} from \"./interfaces/IERC20SafeTransfers.sol\";\nimport {IERC20BatchTransfers} from \"./interfaces/IERC20BatchTransfers.sol\";\nimport {IERC20Metadata} from \"./interfaces/IERC20Metadata.sol\";\nimport {IERC20Permit} from \"./interfaces/IERC20Permit.sol\";\nimport {IERC20Receiver} from \"./interfaces/IERC20Receiver.sol\";\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol\";\n\n/**\n * @title ERC20 Fungible Token Contract.\n */\ncontract ERC20 is\n    ManagedIdentity,\n    IERC165,\n    IERC20,\n    IERC20Detailed,\n    IERC20Metadata,\n    IERC20Allowance,\n    IERC20BatchTransfers,\n    IERC20SafeTransfers,\n    IERC20Permit\n{\n    using AddressIsContract for address;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    uint256 public immutable deploymentChainId;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    /// @inheritdoc IERC20Permit\n    mapping(address => uint256) public override nonces;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal immutable _decimals;\n    string internal _tokenURI;\n\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n    uint256 internal _totalSupply;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        deploymentChainId = chainId;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\n    }\n\n    //======================================================= ERC165 ========================================================//\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC20).interfaceId ||\n            interfaceId == type(IERC20Detailed).interfaceId ||\n            interfaceId == type(IERC20Metadata).interfaceId ||\n            interfaceId == type(IERC20Allowance).interfaceId ||\n            interfaceId == type(IERC20BatchTransfers).interfaceId ||\n            interfaceId == type(IERC20SafeTransfers).interfaceId ||\n            interfaceId == type(IERC20Permit).interfaceId;\n    }\n\n    //======================================================== ERC20 ========================================================//\n\n    /// @inheritdoc IERC20\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /// @inheritdoc IERC20\n    function approve(address spender, uint256 value) external virtual override returns (bool) {\n        _approve(_msgSender(), spender, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function transfer(address to, uint256 value) external virtual override returns (bool) {\n        _transfer(_msgSender(), to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external virtual override returns (bool) {\n        _transferFrom(_msgSender(), from, to, value);\n        return true;\n    }\n\n    //==================================================== ERC20Detailed ====================================================//\n\n    /// @inheritdoc IERC20Detailed\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    /// @inheritdoc IERC20Detailed\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @inheritdoc IERC20Detailed\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    //==================================================== ERC20Metadata ====================================================//\n\n    /// @inheritdoc IERC20Metadata\n    function tokenURI() external view override returns (string memory) {\n        return _tokenURI;\n    }\n\n    //=================================================== ERC20Allowance ====================================================//\n\n    /// @inheritdoc IERC20Allowance\n    function increaseAllowance(address spender, uint256 addedValue) external virtual override returns (bool) {\n        require(spender != address(0), \"ERC20: zero address spender\");\n        address owner = _msgSender();\n        uint256 allowance_ = _allowances[owner][spender];\n        if (addedValue != 0) {\n            uint256 newAllowance = allowance_ + addedValue;\n            require(newAllowance > allowance_, \"ERC20: allowance overflow\");\n            _allowances[owner][spender] = newAllowance;\n            allowance_ = newAllowance;\n        }\n        emit Approval(owner, spender, allowance_);\n\n        return true;\n    }\n\n    /// @inheritdoc IERC20Allowance\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual override returns (bool) {\n        require(spender != address(0), \"ERC20: zero address spender\");\n        _decreaseAllowance(_msgSender(), spender, subtractedValue);\n        return true;\n    }\n\n    //================================================= ERC20BatchTransfers =================================================//\n\n    /// @inheritdoc IERC20BatchTransfers\n    function batchTransfer(address[] calldata recipients, uint256[] calldata values) external virtual override returns (bool) {\n        uint256 length = recipients.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n        address sender = _msgSender();\n        uint256 balance = _balances[sender];\n\n        uint256 totalValue;\n        uint256 selfTransferTotalValue;\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"ERC20: to zero address\");\n\n            uint256 value = values[i];\n            if (value != 0) {\n                uint256 newTotalValue = totalValue + value;\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\n                totalValue = newTotalValue;\n                if (sender != to) {\n                    _balances[to] += value;\n                } else {\n                    require(value <= balance, \"ERC20: insufficient balance\");\n                    selfTransferTotalValue += value; // cannot overflow as 'selfTransferTotalValue <= totalValue' is always true\n                }\n            }\n            emit Transfer(sender, to, value);\n        }\n\n        if (totalValue != 0 && totalValue != selfTransferTotalValue) {\n            uint256 newBalance = balance - totalValue;\n            require(newBalance < balance, \"ERC20: insufficient balance\"); // balance must be sufficient, including self-transfers\n            _balances[sender] = newBalance + selfTransferTotalValue; // do not deduct self-transfers from the sender balance\n        }\n        return true;\n    }\n\n    /// @inheritdoc IERC20BatchTransfers\n    function batchTransferFrom(\n        address from,\n        address[] calldata recipients,\n        uint256[] calldata values\n    ) external virtual override returns (bool) {\n        uint256 length = recipients.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n\n        uint256 balance = _balances[from];\n\n        uint256 totalValue;\n        uint256 selfTransferTotalValue;\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"ERC20: to zero address\");\n\n            uint256 value = values[i];\n\n            if (value != 0) {\n                uint256 newTotalValue = totalValue + value;\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\n                totalValue = newTotalValue;\n                if (from != to) {\n                    _balances[to] += value;\n                } else {\n                    require(value <= balance, \"ERC20: insufficient balance\");\n                    selfTransferTotalValue += value; // cannot overflow as 'selfTransferTotalValue <= totalValue' is always true\n                }\n            }\n\n            emit Transfer(from, to, value);\n        }\n\n        if (totalValue != 0 && totalValue != selfTransferTotalValue) {\n            uint256 newBalance = balance - totalValue;\n            require(newBalance < balance, \"ERC20: insufficient balance\"); // balance must be sufficient, including self-transfers\n            _balances[from] = newBalance + selfTransferTotalValue; // do not deduct self-transfers from the sender balance\n        }\n\n        address sender = _msgSender();\n        if (from != sender) {\n            _decreaseAllowance(from, sender, totalValue);\n        }\n\n        return true;\n    }\n\n    //================================================= ERC20SafeTransfers ==================================================//\n\n    /// @inheritdoc IERC20SafeTransfers\n    function safeTransfer(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override returns (bool) {\n        address sender = _msgSender();\n        _transfer(sender, to, amount);\n        if (to.isContract()) {\n            require(IERC20Receiver(to).onERC20Received(sender, sender, amount, data) == type(IERC20Receiver).interfaceId, \"ERC20: transfer refused\");\n        }\n        return true;\n    }\n\n    /// @inheritdoc IERC20SafeTransfers\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override returns (bool) {\n        address sender = _msgSender();\n        _transferFrom(sender, from, to, amount);\n        if (to.isContract()) {\n            require(IERC20Receiver(to).onERC20Received(sender, from, amount, data) == type(IERC20Receiver).interfaceId, \"ERC20: transfer refused\");\n        }\n        return true;\n    }\n\n    //===================================================== ERC20Permit =====================================================//\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        // recompute the domain separator in case of fork and chainid update\n        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId, bytes(_name));\n    }\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override {\n        require(owner != address(0), \"ERC20: zero address owner\");\n        require(block.timestamp <= deadline, \"ERC20: expired permit\");\n        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n        address signer = ecrecover(hash, v, r, s);\n        require(signer == owner, \"ERC20: invalid permit\");\n        _approve(owner, spender, value);\n    }\n\n    //============================================ High-level Internal Functions ============================================//\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal {\n        require(spender != address(0), \"ERC20: zero address spender\");\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 subtractedValue\n    ) internal {\n        uint256 allowance_ = _allowances[owner][spender];\n\n        if (allowance_ != type(uint256).max && subtractedValue != 0) {\n            // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n            uint256 newAllowance = allowance_ - subtractedValue;\n            require(newAllowance < allowance_, \"ERC20: insufficient allowance\");\n            _allowances[owner][spender] = newAllowance;\n            allowance_ = newAllowance;\n        }\n        emit Approval(owner, spender, allowance_);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual {\n        require(to != address(0), \"ERC20: to zero address\");\n\n        if (value != 0) {\n            uint256 balance = _balances[from];\n            uint256 newBalance = balance - value;\n            require(newBalance < balance, \"ERC20: insufficient balance\");\n            if (from != to) {\n                _balances[from] = newBalance;\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    function _transferFrom(\n        address sender,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _transfer(from, to, value);\n        if (from != sender) {\n            _decreaseAllowance(from, sender, value);\n        }\n    }\n\n    function _mint(address to, uint256 value) internal virtual {\n        require(to != address(0), \"ERC20: zero address\");\n        uint256 supply = _totalSupply;\n        if (value != 0) {\n            uint256 newSupply = supply + value;\n            require(newSupply > supply, \"ERC20: supply overflow\");\n            _totalSupply = newSupply;\n            _balances[to] += value; // balance cannot overflow if supply does not\n        }\n        emit Transfer(address(0), to, value);\n    }\n\n    function _batchMint(address[] memory recipients, uint256[] memory values) internal virtual {\n        uint256 length = recipients.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n\n        uint256 totalValue;\n        for (uint256 i; i != length; ++i) {\n            address to = recipients[i];\n            require(to != address(0), \"ERC20: zero address\");\n\n            uint256 value = values[i];\n            if (value != 0) {\n                uint256 newTotalValue = totalValue + value;\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\n                totalValue = newTotalValue;\n                _balances[to] += value; // balance cannot overflow if supply does not\n            }\n            emit Transfer(address(0), to, value);\n        }\n\n        if (totalValue != 0) {\n            uint256 supply = _totalSupply;\n            uint256 newSupply = supply + totalValue;\n            require(newSupply > supply, \"ERC20: supply overflow\");\n            _totalSupply = newSupply;\n        }\n    }\n\n    function _burn(address from, uint256 value) internal virtual {\n        if (value != 0) {\n            uint256 balance = _balances[from];\n            uint256 newBalance = balance - value;\n            require(newBalance < balance, \"ERC20: insufficient balance\");\n            _balances[from] = newBalance;\n            _totalSupply -= value; // will not underflow if balance does not\n        }\n        emit Transfer(from, address(0), value);\n    }\n\n    function _burnFrom(address from, uint256 value) internal virtual {\n        _burn(from, value);\n        address sender = _msgSender();\n        if (from != sender) {\n            _decreaseAllowance(from, sender, value);\n        }\n    }\n\n    function _batchBurnFrom(address[] memory owners, uint256[] memory values) internal virtual {\n        uint256 length = owners.length;\n        require(length == values.length, \"ERC20: inconsistent arrays\");\n\n        address sender = _msgSender();\n\n        uint256 totalValue;\n        for (uint256 i; i != length; ++i) {\n            address from = owners[i];\n            uint256 value = values[i];\n            if (value != 0) {\n                uint256 balance = _balances[from];\n                uint256 newBalance = balance - value;\n                require(newBalance < balance, \"ERC20: insufficient balance\");\n                _balances[from] = newBalance;\n                totalValue += value; // totalValue cannot overflow if the individual balances do not underflow\n            }\n            emit Transfer(from, address(0), value);\n\n            if (from != sender) {\n                _decreaseAllowance(from, sender, value);\n            }\n        }\n\n        if (totalValue != 0) {\n            _totalSupply -= totalValue; // _totalSupply cannot underfow as balances do not underflow\n        }\n    }\n\n    //============================================== Helper Internal Functions ==============================================//\n\n    function _calculateDomainSeparator(uint256 chainId, bytes memory name_) private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(name_),\n                    keccak256(\"1\"),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, basic interface.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: The ERC-165 identifier for this interface is 0x36372b07.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when tokens are transferred, including zero value transfers.\n     * @param _from The account where the transferred tokens are withdrawn from.\n     * @param _to The account where the transferred tokens are deposited to.\n     * @param _value The amount of tokens being transferred.\n     */\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n     * @dev Emitted when a successful call to {IERC20-approve(address,uint256)} is made.\n     * @param _owner The account granting an allowance to `_spender`.\n     * @param _spender The account being granted an allowance from `_owner`.\n     * @param _value The allowance amount being granted.\n     */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n     * @notice Returns the total token supply.\n     * @return The total token supply.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Returns the account balance of another account with address `owner`.\n     * @param owner The account whose balance will be returned.\n     * @return The account balance of another account with address `owner`.\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * Transfers `value` amount of tokens to address `to`.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if the sender does not have enough balance.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\n     * @param to The receiver account.\n     * @param value The amount of tokens to transfer.\n     * @return True if the transfer succeeds, false otherwise.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @notice Transfers `value` amount of tokens from address `from` to address `to`.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `from` does not have at least `value` of balance.\n     * @dev Reverts if the sender is not `from` and has not been approved by `from` for at least `value`.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\n     * @param from The emitter account.\n     * @param to The receiver account.\n     * @param value The amount of tokens to transfer.\n     * @return True if the transfer succeeds, false otherwise.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    /**\n     * Sets `value` as the allowance from the caller to `spender`.\n     *  IMPORTANT: Beware that changing an allowance with this method brings the risk\n     *  that someone may use both the old and the new allowance by unfortunate\n     *  transaction ordering. One possible solution to mitigate this race\n     *  condition is to first reduce the spender's allowance to 0 and set the\n     *  desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @dev Reverts if `spender` is the zero address.\n     * @dev Emits the {IERC20-Approval} event.\n     * @param spender The account being granted the allowance by the message caller.\n     * @param value The allowance amount to grant.\n     * @return True if the approval succeeds, false otherwise.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * Returns the amount which `spender` is allowed to spend on behalf of `owner`.\n     * @param owner The account that has granted an allowance to `spender`.\n     * @param spender The account that was granted an allowance by `owner`.\n     * @return The amount which `spender` is allowed to spend on behalf of `owner`.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Detailed.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: the ERC-165 identifier for this interface is 0xa219a025.\n */\ninterface IERC20Detailed {\n    /**\n     * Returns the name of the token. E.g. \"My Token\".\n     * @return The name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * Returns the symbol of the token. E.g. \"HIX\".\n     * @return The symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * Returns the number of decimals used to display the balances.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei.\n     *\n     * @dev Note: This information is only used for _display_ purposes: it does  not impact the arithmetic of the contract.\n     * @return The number of decimals used to display the balances.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Allowance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Allowance.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: the ERC-165 identifier for this interface is 0x9d075186.\n */\ninterface IERC20Allowance {\n    /**\n     * Increases the allowance granted by the sender to `spender` by `value`.\n     *  This is an alternative to {approve} that can be used as a mitigation for\n     *  problems described in {IERC20-approve}.\n     * @dev Reverts if `spender` is the zero address.\n     * @dev Reverts if `spender`'s allowance overflows.\n     * @dev Emits an {IERC20-Approval} event with an updated allowance for `spender`.\n     * @param spender The account whose allowance is being increased by the message caller.\n     * @param value The allowance amount increase.\n     * @return True if the allowance increase succeeds, false otherwise.\n     */\n    function increaseAllowance(address spender, uint256 value) external returns (bool);\n\n    /**\n     * Decreases the allowance granted by the sender to `spender` by `value`.\n     *  This is an alternative to {approve} that can be used as a mitigation for\n     *  problems described in {IERC20-approve}.\n     * @dev Reverts if `spender` is the zero address.\n     * @dev Reverts if `spender` has an allowance with the message caller for less than `value`.\n     * @dev Emits an {IERC20-Approval} event with an updated allowance for `spender`.\n     * @param spender The account whose allowance is being decreased by the message caller.\n     * @param value The allowance amount decrease.\n     * @return True if the allowance decrease succeeds, false otherwise.\n     */\n    function decreaseAllowance(address spender, uint256 value) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20SafeTransfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Safe Transfers.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: the ERC-165 identifier for this interface is 0x53f41a97.\n */\ninterface IERC20SafeTransfers {\n    /**\n     * Transfers tokens from the caller to `to`. If this address is a contract, then calls `onERC20Received(address,address,uint256,bytes)` on it.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `value` is greater than the sender's balance.\n     * @dev Reverts if `to` is a contract which does not implement `onERC20Received(address,address,uint256,bytes)`.\n     * @dev Reverts if `to` is a contract and the call to `onERC20Received(address,address,uint256,bytes)` returns a wrong value.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @param to The address for the tokens to be transferred to.\n     * @param amount The amount of tokens to be transferred.\n     * @param data Optional additional data with no specified format, to be passed to the receiver contract.\n     * @return true.\n     */\n    function safeTransfer(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    /**\n     * Transfers tokens from `from` to another address, using the allowance mechanism.\n     *  If this address is a contract, then calls `onERC20Received(address,address,uint256,bytes)` on it.\n     * @dev Reverts if `to` is the zero address.\n     * @dev Reverts if `value` is greater than `from`'s balance.\n     * @dev Reverts if the sender does not have at least `value` allowance by `from`.\n     * @dev Reverts if `to` is a contract which does not implement `onERC20Received(address,address,uint256,bytes)`.\n     * @dev Reverts if `to` is a contract and the call to `onERC20Received(address,address,uint256,bytes)` returns a wrong value.\n     * @dev Emits an {IERC20-Transfer} event.\n     * @param from The address which owns the tokens to be transferred.\n     * @param to The address for the tokens to be transferred to.\n     * @param amount The amount of tokens to be transferred.\n     * @param data Optional additional data with no specified format, to be passed to the receiver contract.\n     * @return true.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20BatchTransfers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, optional extension: Batch Transfers.\n * @dev See https://eips.ethereum.org/EIPS/eip-20\n * @dev Note: the ERC-165 identifier for this interface is 0xc05327e6.\n */\ninterface IERC20BatchTransfers {\n    /**\n     * Moves multiple `amounts` tokens from the caller's account to each of `recipients`.\n     * @dev Reverts if `recipients` and `amounts` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if the caller has an insufficient balance.\n     * @dev Emits an {IERC20-Transfer} event for each individual transfer.\n     * @param recipients the list of recipients to transfer the tokens to.\n     * @param amounts the amounts of tokens to transfer to each of `recipients`.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external returns (bool);\n\n    /**\n     * Moves multiple `amounts` tokens from an account to each of `recipients`.\n     * @dev Reverts if `recipients` and `amounts` have different lengths.\n     * @dev Reverts if one of `recipients` is the zero address.\n     * @dev Reverts if `from` has an insufficient balance.\n     * @dev Reverts if the sender is not `from` and has an insufficient allowance.\n     * @dev Emits an {IERC20-Transfer} event for each individual transfer.\n     * @dev Emits an {IERC20-Approval} event.\n     * @param from The address which owns the tokens to be transferred.\n     * @param recipients the list of recipients to transfer the tokens to.\n     * @param amounts the amounts of tokens to transfer to each of `recipients`.\n     * @return a boolean value indicating whether the operation succeeded.\n     */\n    function batchTransferFrom(\n        address from,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external returns (bool);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, ERC1046 optional extension: Metadata.\n * @dev See https://eips.ethereum.org/EIPS/eip-1046\n * @dev Note: the ERC-165 identifier for this interface is 0x3c130d90.\n */\ninterface IERC20Metadata {\n    /**\n     * Returns a distinct Uniform Resource Identifier (URI) for the token metadata.\n     * @return a distinct Uniform Resource Identifier (URI) for the token metadata.\n     */\n    function tokenURI() external view returns (string memory);\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title ERC20 Token Standard, ERC2612 optional extension: permit – 712-signed approvals\n * Interface for allowing ERC20 approvals to be made via ECDSA `secp256k1` signatures.\n * @dev See https://eips.ethereum.org/EIPS/eip-2612\n * @dev Note: the ERC-165 identifier for this interface is 0x9d8ff7da.\n */\ninterface IERC20Permit {\n    /**\n     * Sets `value` as the allowance of `spender` over the tokens of `owner`, given `owner` account's signed permit.\n     * @dev WARNING: The standard ERC-20 race condition for approvals applies to `permit()` as well: https://swcregistry.io/docs/SWC-114\n     * @dev Reverts if `owner` is the zero address.\n     * @dev Reverts if the current blocktime is > `deadline`.\n     * @dev Reverts if `r`, `s`, and `v` is not a valid `secp256k1` signature from `owner`.\n     * @dev Emits an {IERC20-Approval} event.\n     * @param owner The token owner granting the allowance to `spender`.\n     * @param spender The token spender being granted the allowance by `owner`.\n     * @param value The token amount of the allowance.\n     * @param deadline The deadline from which the permit signature is no longer valid.\n     * @param v Permit signature v parameter\n     * @param r Permit signature r parameter.\n     * @param s Permis signature s parameter.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * Returns the current permit nonce of `owner`.\n     * @param owner the address to check the nonce of.\n     * @return the current permit nonce of `owner`.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * Returns the EIP-712 encoded hash struct of the domain-specific information for permits.\n     *\n     * @dev A common ERC-20 permit implementation choice for the `DOMAIN_SEPARATOR` is:\n     *\n     *  keccak256(\n     *      abi.encode(\n     *          keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n     *          keccak256(bytes(name)),\n     *          keccak256(bytes(version)),\n     *          chainId,\n     *          address(this)))\n     *\n     *  where\n     *   - `name` (string) is the ERC-20 token name.\n     *   - `version` (string) refers to the ERC-20 token contract version.\n     *   - `chainId` (uint256) is the chain ID to which the ERC-20 token contract is deployed to.\n     *   - `verifyingContract` (address) is the ERC-20 token contract address.\n     *\n     * @return the EIP-712 encoded hash struct of the domain-specific information for permits.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/token/ERC20/REVVMotorsportShard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {IERC20Mintable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Mintable.sol\";\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol\";\nimport {Recoverable} from \"@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol\";\nimport {UsingUniversalForwarding} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol\";\nimport {ERC20Burnable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20Burnable.sol\";\n\n/**\n * @title REVV Motorsport Catalyst Shards.\n */\ncontract REVVMotorsportShard is Recoverable, UsingUniversalForwarding, ERC20Burnable, IERC20Mintable, MinterRole {\n    constructor(IForwarderRegistry forwarderRegistry)\n        ERC20Burnable(\"REVV Motorsport Shard\", \"SHRD\", 18)\n        MinterRole(msg.sender)\n        UsingUniversalForwarding(forwarderRegistry, address(0))\n    {}\n\n    //================================================ ERC20Metadata (admin) ================================================//\n\n    /**\n     * Sets the token metadata URI.\n     * @dev Reverts if not called by the contract owner.\n     * @param tokenURI_ the new token metadata URI.\n     */\n    function setTokenURI(string calldata tokenURI_) external {\n        _requireOwnership(_msgSender());\n        _tokenURI = tokenURI_;\n    }\n\n    //================================================ ERC20Mintable (admin) ================================================//\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function mint(address to, uint256 value) public virtual override {\n        _requireMinter(_msgSender());\n        _mint(to, value);\n    }\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function batchMint(address[] memory recipients, uint256[] memory values) public virtual override {\n        _requireMinter(_msgSender());\n        _batchMint(recipients, values);\n    }\n\n    //======================================== Meta Transactions Internal Functions =========================================//\n\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\n        return UsingUniversalForwarding._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\n        return UsingUniversalForwarding._msgData();\n    }\n}\n"
    },
    "contracts/token/ERC20/PolygonREVVRacingCatalyst.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {IERC20Mintable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Mintable.sol\";\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol\";\nimport {Recoverable} from \"@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol\";\nimport {UsingUniversalForwarding} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol\";\nimport {PolygonChildERC20Burnable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/polygon/child/PolygonChildERC20Burnable.sol\";\n\n/**\n * @title REVV Racing Catalysts Token (Polygon version).\n */\ncontract PolygonREVVRacingCatalyst is Recoverable, UsingUniversalForwarding, PolygonChildERC20Burnable, IERC20Mintable, MinterRole {\n    constructor(IForwarderRegistry forwarderRegistry, address childChainManager)\n        PolygonChildERC20Burnable(\"REVV Racing Catalyst\", \"CATA\", 18, childChainManager)\n        MinterRole(msg.sender)\n        UsingUniversalForwarding(forwarderRegistry, address(0))\n    {}\n\n    //================================================ ERC20Metadata (admin) ================================================//\n\n    /**\n     * Sets the token metadata URI.\n     * @dev Reverts if not called by the contract owner.\n     * @param tokenURI_ the new token metadata URI.\n     */\n    function setTokenURI(string calldata tokenURI_) external {\n        _requireOwnership(_msgSender());\n        _tokenURI = tokenURI_;\n    }\n\n    //================================================ ERC20Mintable (admin) ================================================//\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function mint(address to, uint256 value) public virtual override {\n        _requireMinter(_msgSender());\n        _mint(to, value);\n    }\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function batchMint(address[] memory recipients, uint256[] memory values) public virtual override {\n        _requireMinter(_msgSender());\n        _batchMint(recipients, values);\n    }\n\n    //======================================== Meta Transactions Internal Functions =========================================//\n\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\n        return UsingUniversalForwarding._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\n        return UsingUniversalForwarding._msgData();\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/polygon/child/PolygonChildERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IERC165} from \"@animoca/ethereum-contracts-core/contracts/introspection/IERC165.sol\";\nimport {IERC20Receiver} from \"./../../interfaces/IERC20Receiver.sol\";\nimport {ERC20Receiver, PolygonChildERC20Base} from \"./PolygonChildERC20Base.sol\";\nimport {ERC20Burnable} from \"./../../ERC20Burnable.sol\";\n\n/**\n * @title ERC20 Fungible Token Contract, Child Burnable version (for Polygon).\n * Polygon bridging ERC20 child token which burns the token and emits a `Withdrawn(address account, uint256 value)` event on exit.\n * @dev This contract should be deployed on the Child Chain (Polygon).\n */\ncontract PolygonChildERC20Burnable is ERC20Burnable, PolygonChildERC20Base {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address childChainManager\n    ) ERC20Burnable(name_, symbol_, decimals_) PolygonChildERC20Base(childChainManager) {}\n\n    //======================================================= ERC165 ========================================================//\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC20Burnable, ERC20Receiver) returns (bool) {\n        return ERC20Burnable.supportsInterface(interfaceId) || ERC20Receiver.supportsInterface(interfaceId);\n    }\n\n    //===================================================== ChildToken ======================================================//\n\n    /**\n     * Called when tokens have been deposited on the root chain.\n     * @dev Should handle deposit by minting the required amount for user.\n     * @dev Reverts if not sent by the depositor (ChildChainManager).\n     * @param user address for whom deposit has been done.\n     * @param depositData abi encoded amount.\n     */\n    function deposit(address user, bytes calldata depositData) external override {\n        _requireDepositorRole(_msgSender());\n        uint256 amount = abi.decode(depositData, (uint256));\n        _mint(user, amount);\n    }\n\n    /**\n     * Called when user wants to withdraw tokens back to the root chain.\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on the root chain.\n     * @dev Emits a {Withdrawn} event.\n     * @param amount amount of tokens to withdraw\n     */\n    function withdraw(uint256 amount) external {\n        address sender = _msgSender();\n        _burnFrom(sender, amount);\n        emit Withdrawn(sender, amount);\n    }\n\n    //==================================================== ERC20Receiver ====================================================//\n\n    /**\n     * Called when user wants to withdraw tokens back to the root chain (no pre-approval required).\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain.\n     * @dev Reverts if the sender is not this contract.\n     * @dev Emits a {Withdrawn} event.\n     * @inheritdoc IERC20Receiver\n     */\n    function onERC20Received(\n        address, /*operator*/\n        address from,\n        uint256 amount,\n        bytes calldata /*data*/\n    ) external virtual override returns (bytes4) {\n        require(msg.sender == address(this), \"ChildERC20: wrong sender\");\n        _burn(address(this), amount);\n        emit Withdrawn(from, amount);\n        return _ERC20_RECEIVED;\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/ERC20/polygon/child/PolygonChildERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IPolygonChildToken} from \"../../../common/polygon/interfaces/IPolygonChildToken.sol\";\nimport {IERC20Receiver} from \"./../../interfaces/IERC20Receiver.sol\";\nimport {ERC20Receiver} from \"./../../ERC20Receiver.sol\";\n\n/**\n * @title ERC20 Child Token Base (for Polygon).\n * Polygon bridging ERC20 child token which emits a `Withdrawn(address account, uint256 value)` event on exit.\n * @dev This contract should be deployed on the Child Chain (Polygon).\n * @dev The function `deposit(address,bytes)` needs to be implemented by a child contract.\n * @dev A function `withdraw(uint256)` can be implemented by a child contract to better integrate with Polygon bridge website.\n */\nabstract contract PolygonChildERC20Base is IPolygonChildToken, ERC20Receiver {\n    event Withdrawn(address account, uint256 value);\n\n    // see https://github.com/maticnetwork/pos-portal/blob/master/contracts/child/ChildChainManager/ChildChainManager.sol\n    address public childChainManager;\n\n    /**\n     * Constructor\n     * @param childChainManager_ the Polygon/MATIC ChildChainManager proxy address.\n     */\n    constructor(address childChainManager_) {\n        childChainManager = childChainManager_;\n    }\n\n    //============================================== Helper Internal Functions ==============================================//\n\n    function _requireDepositorRole(address account) internal view {\n        require(account == childChainManager, \"ChildERC20: only depositor\");\n    }\n}\n"
    },
    "@animoca/ethereum-contracts-assets/contracts/token/common/polygon/interfaces/IPolygonChildToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\n/**\n * @title Child Token interface for Polygon POS portal.\n */\ninterface IPolygonChildToken {\n    /**\n     * Receive a deposit from the POS portal.\n     * @dev Reverts if the sender is not the Child Chain manager.\n     * @param user Address who receives the deposit.\n     * @param depositData Extra data for deposit (amount for ERC20, token id for ERC721 etc.) [ABI encoded]\n     */\n    function deposit(address user, bytes calldata depositData) external;\n}\n"
    },
    "contracts/token/ERC20/PolygonREVVMotorsportShard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {IERC20Mintable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/interfaces/IERC20Mintable.sol\";\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol\";\nimport {Recoverable} from \"@animoca/ethereum-contracts-core/contracts/utils/Recoverable.sol\";\nimport {UsingUniversalForwarding} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol\";\nimport {MinterRole} from \"@animoca/ethereum-contracts-core/contracts/access/MinterRole.sol\";\nimport {PolygonChildERC20Burnable} from \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/polygon/child/PolygonChildERC20Burnable.sol\";\n\n/**\n * @title REVV Motorsport Catalyst Shards.\n */\ncontract PolygonREVVMotorsportShard is Recoverable, UsingUniversalForwarding, PolygonChildERC20Burnable, IERC20Mintable, MinterRole {\n    constructor(IForwarderRegistry forwarderRegistry, address childChainManager)\n        PolygonChildERC20Burnable(\"REVV Motorsport Shard\", \"SHRD\", 18, childChainManager)\n        MinterRole(msg.sender)\n        UsingUniversalForwarding(forwarderRegistry, address(0))\n    {}\n\n    //================================================ ERC20Metadata (admin) ================================================//\n\n    /**\n     * Sets the token metadata URI.\n     * @dev Reverts if not called by the contract owner.\n     * @param tokenURI_ the new token metadata URI.\n     */\n    function setTokenURI(string calldata tokenURI_) external {\n        _requireOwnership(_msgSender());\n        _tokenURI = tokenURI_;\n    }\n\n    //================================================ ERC20Mintable (admin) ================================================//\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function mint(address to, uint256 value) public virtual override {\n        _requireMinter(_msgSender());\n        _mint(to, value);\n    }\n\n    /// @inheritdoc IERC20Mintable\n    /// @dev Reverts if the sender is not a minter.\n    function batchMint(address[] memory recipients, uint256[] memory values) public virtual override {\n        _requireMinter(_msgSender());\n        _batchMint(recipients, values);\n    }\n\n    //======================================== Meta Transactions Internal Functions =========================================//\n\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\n        return UsingUniversalForwarding._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\n        return UsingUniversalForwarding._msgData();\n    }\n}\n"
    },
    "contracts/token/ERC20/mocks/REVVRacingCatalystMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {REVVRacingCatalyst} from \"./../REVVRacingCatalyst.sol\";\n\ncontract REVVRacingCatalystMock is REVVRacingCatalyst {\n    constructor(\n        address[] memory recipients,\n        uint256[] memory values,\n        IForwarderRegistry forwarderRegistry\n    ) REVVRacingCatalyst(forwarderRegistry) {\n        _batchMint(recipients, values);\n    }\n\n    //=============================================== Mock Coverage Functions ===============================================//\n\n    function msgData() external view returns (bytes memory ret) {\n        return _msgData();\n    }\n}\n"
    },
    "contracts/token/ERC20/mocks/REVVMotorsportShardMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {REVVMotorsportShard} from \"./../REVVMotorsportShard.sol\";\n\ncontract REVVMotorsportShardMock is REVVMotorsportShard {\n    constructor(\n        address[] memory recipients,\n        uint256[] memory values,\n        IForwarderRegistry forwarderRegistry\n    ) REVVMotorsportShard(forwarderRegistry) {\n        _batchMint(recipients, values);\n    }\n\n    //=============================================== Mock Coverage Functions ===============================================//\n\n    function msgData() external view returns (bytes memory ret) {\n        return _msgData();\n    }\n}\n"
    },
    "contracts/token/ERC20/mocks/PolygonREVVRacingCatalystMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {PolygonREVVRacingCatalyst} from \"./../PolygonREVVRacingCatalyst.sol\";\n\ncontract PolygonREVVRacingCatalystMock is PolygonREVVRacingCatalyst {\n    constructor(IForwarderRegistry forwarderRegistry, address childChainManager) PolygonREVVRacingCatalyst(forwarderRegistry, childChainManager) {}\n\n    //=============================================== Mock Coverage Functions ===============================================//\n\n    function msgData() external view returns (bytes memory ret) {\n        return _msgData();\n    }\n}\n"
    },
    "contracts/token/ERC20/mocks/PolygonREVVMotorsportShardMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.8.0;\n\nimport {IForwarderRegistry} from \"ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol\";\nimport {PolygonREVVMotorsportShard} from \"./../PolygonREVVMotorsportShard.sol\";\n\ncontract PolygonREVVMotorsportShardMock is PolygonREVVMotorsportShard {\n    constructor(IForwarderRegistry forwarderRegistry, address childChainManager) PolygonREVVMotorsportShard(forwarderRegistry, childChainManager) {}\n\n    //=============================================== Mock Coverage Functions ===============================================//\n\n    function msgData() external view returns (bytes memory ret) {\n        return _msgData();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}